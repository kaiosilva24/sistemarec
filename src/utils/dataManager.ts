// Utility functions for data persistence and management with Supabase
import { supabase } from "../../supabase/supabase";
import type {
  RawMaterial,
  Product,
  Employee,
  Customer,
  Supplier,
  StockItem,
  ProductionRecipe,
  ProductionEntry,
  FixedCost,
  VariableCost,
  CashFlowEntry,
  Salesperson,
  DefectiveTireSale,
  CostSimulation,
  WarrantyEntry,
  ResaleProduct,
  PendingSale,
  Debt,
} from "@/types/financial";

export class DataManager {
  private static instance: DataManager;
  private listeners: Map<string, Set<() => void>> = new Map();

  // Access Supabase client from the imported instance
  private get supabase() {
    return supabase;
  }

  static getInstance(): DataManager {
    if (!DataManager.instance) {
      DataManager.instance = new DataManager();
    }
    return DataManager.instance;
  }

  // Generic database operations
  async saveToDatabase<
    T extends {
      id?: string;
      created_at?: string;
      updated_at?: string;
      last_updated?: string;
    },
  >(tableName: string, data: T): Promise<T | null> {
    try {
      const { id, created_at, updated_at, last_updated, ...dataToSave } = data;

      console.log(`üîß [DataManager] saveToDatabase para ${tableName}:`, {
        originalData: data,
        cleanedData: dataToSave,
        removedFields: { id, created_at, updated_at, last_updated },
      });

      if (!id || id.startsWith("temp_")) {
        // Insert new record (no id or temp id)
        console.log(`üÜï [DataManager] Inserindo novo registro em ${tableName}...`);
        const { data: insertedData, error } = await this.supabase
          .from(tableName)
          .insert([dataToSave])
          .select()
          .single();

        if (error) {
          console.error(
            `‚ùå [DataManager] Erro detalhado ao inserir em ${tableName}:`,
            {
              error,
              dataToSave,
              originalData: data,
            },
          );
          throw error;
        }

        console.log(
          `‚úÖ [DataManager] Dados inseridos em ${tableName}:`,
          insertedData,
        );
        
        // Log espec√≠fico para production_entries para debug da data
        if (tableName === 'production_entries' && insertedData) {
          console.log('üîç [DataManager] DEBUG DATA SALVA:', {
            production_date_raw: (insertedData as any).production_date,
            production_date_type: typeof (insertedData as any).production_date,
            production_date_parsed: new Date((insertedData as any).production_date),
            production_date_formatted_ptbr: new Date((insertedData as any).production_date).toLocaleDateString('pt-BR'),
            production_date_formatted_iso: new Date((insertedData as any).production_date).toISOString(),
            timezone_offset: new Date().getTimezoneOffset(),
            current_date: new Date().toISOString(),
            data_enviada_para_supabase: dataToSave,
            data_retornada_do_supabase: insertedData,
          });
        }
        
        return insertedData;
      } else if (id) {
        // Update existing record
        const { data: updatedData, error } = await this.supabase
          .from(tableName)
          .update(dataToSave)
          .eq("id", id)
          .select()
          .single();

        if (error) {
          console.error(
            `‚ùå [DataManager] Erro detalhado ao atualizar em ${tableName}:`,
            {
              error,
              dataToSave,
              originalData: data,
              id,
            },
          );
          throw error;
        }

        console.log(
          `‚úÖ [DataManager] Dados atualizados em ${tableName}:`,
          updatedData,
        );
        return updatedData;
      }

      return null;
    } catch (error) {
      console.error(`‚ùå [DataManager] Erro ao salvar em ${tableName}:`, error);
      return null;
    }
  }

  async loadFromDatabase<T>(tableName: string): Promise<T[]> {
    try {
      const { data, error } = await this.supabase
        .from(tableName)
        .select("*")
        .order("created_at", { ascending: false });

      if (error) throw error;

      console.log(
        `‚úÖ [DataManager] Dados carregados de ${tableName}:`,
        data?.length || 0,
      );
      return data || [];
    } catch (error) {
      console.error(
        `‚ùå [DataManager] Erro ao carregar de ${tableName}:`,
        error,
      );
      return [];
    }
  }

  private async updateInDatabase(tableName: string, id: string, updates: any): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from(tableName)
        .update(updates)
        .eq('id', id);

      if (error) {
        console.error(`Erro ao atualizar ${tableName}:`, error);
        return false;
      }

      return true;
    } catch (error) {
      console.error(`Erro ao atualizar ${tableName}:`, error);
      return false;
    }
  }

  private async deleteFromDatabase(tableName: string, id: string): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from(tableName)
        .delete()
        .eq('id', id);

      if (error) {
        console.error(`Erro ao deletar de ${tableName}:`, error);
        return false;
      }

      return true;
    } catch (error) {
      console.error(`Erro ao deletar de ${tableName}:`, error);
      return false;
    }
  }

  // Remove stock item by item_id (for when products are archived)
  async removeStockItemByItemId(itemId: string): Promise<boolean> {
    try {
      console.log(
        `üóëÔ∏è [DataManager] Removendo item do estoque por item_id: ${itemId}`,
      );

      // First, find the stock item to get details for logging
      const { data: stockItem, error: findError } = await this.supabase
        .from("stock_items")
        .select("*")
        .eq("item_id", itemId)
        .single();

      if (findError) {
        if (findError.code === "PGRST116") {
          console.log(
            `‚ÑπÔ∏è [DataManager] Item n√£o encontrado no estoque: ${itemId}`,
          );
          return true; // Not an error if item doesn't exist in stock
        }
        throw findError;
      }

      if (stockItem) {
        console.log(`üì¶ [DataManager] Item encontrado no estoque:`, {
          id: stockItem.id,
          item_name: stockItem.item_name,
          quantity: stockItem.quantity,
          total_value: stockItem.total_value,
        });

        // Delete the stock item
        const { error: deleteError } = await this.supabase
          .from("stock_items")
          .delete()
          .eq("item_id", itemId);

        if (deleteError) throw deleteError;

        console.log(`‚úÖ [DataManager] Item removido do estoque com sucesso:`, {
          item_id: itemId,
          item_name: stockItem.item_name,
          quantidade_removida: stockItem.quantity,
        });
      }

      return true;
    } catch (error) {
      console.error(
        `‚ùå [DataManager] Erro ao remover item do estoque por item_id ${itemId}:`,
        {
          error: error instanceof Error ? error.message : error,
          stack: error instanceof Error ? error.stack : undefined,
        },
      );
      return false;
    }
  }

  // Specific methods for each entity type
  async saveMaterial(
    material: Omit<RawMaterial, "id" | "created_at" | "updated_at">,
  ): Promise<RawMaterial | null> {
    return this.saveToDatabase("raw_materials", {
      ...material,
      id: `temp_${Date.now()}`,
    });
  }

  async loadMaterials(): Promise<RawMaterial[]> {
    return this.loadFromDatabase<RawMaterial>("raw_materials");
  }

  async updateMaterial(
    id: string,
    updates: Partial<RawMaterial>,
  ): Promise<RawMaterial | null> {
    return this.saveToDatabase("raw_materials", { ...updates, id });
  }

  // Delete material permanently
  async deleteMaterial(id: string): Promise<boolean> {
    try {
      console.log(
        `üóëÔ∏è [DataManager] Deletando mat√©ria-prima permanentemente: ${id}`,
      );

      // First, remove any related stock items
      console.log(
        `üóëÔ∏è [DataManager] Removendo itens de estoque relacionados √† mat√©ria-prima: ${id}`,
      );
      const { error: stockError } = await this.supabase
        .from("stock_items")
        .delete()
        .eq("item_id", id)
        .eq("item_type", "material");

      if (stockError) {
        console.warn(
          "‚ö†Ô∏è [DataManager] Erro ao remover itens de estoque (pode n√£o existir):",
          stockError,
        );
        // Continue with material deletion even if stock removal fails
      } else {
        console.log("‚úÖ [DataManager] Itens de estoque removidos com sucesso");
      }

      // Then delete the material
      const { error: materialError } = await this.supabase
        .from("raw_materials")
        .delete()
        .eq("id", id);

      if (materialError) {
        console.error(
          "‚ùå [DataManager] Erro ao deletar mat√©ria-prima:",
          materialError,
        );
        return false;
      }

      console.log(
        "‚úÖ [DataManager] Mat√©ria-prima deletada permanentemente com sucesso",
      );
      return true;
    } catch (error) {
      console.error(
        "‚ùå [DataManager] Erro cr√≠tico ao deletar mat√©ria-prima:",
        error,
      );
      return false;
    }
  }

  async saveProduct(
    product: Omit<Product, "id" | "created_at" | "updated_at">,
  ): Promise<Product | null> {
    return this.saveToDatabase("products", {
      ...product,
      id: `temp_${Date.now()}`,
    });
  }

  async loadProducts(): Promise<Product[]> {
    return this.loadFromDatabase<Product>("products");
  }

  async updateProduct(
    id: string,
    updates: Partial<Product>,
  ): Promise<Product | null> {
    return this.saveToDatabase("products", { ...updates, id });
  }

  // Delete product permanently
  async deleteProduct(id: string): Promise<boolean> {
    try {
      console.log(`üóëÔ∏è [DataManager] Deletando produto permanentemente: ${id}`);

      // First, remove any related stock items
      console.log(
        `üóëÔ∏è [DataManager] Removendo itens de estoque relacionados ao produto: ${id}`,
      );
      const { error: stockError } = await this.supabase
        .from("stock_items")
        .delete()
        .eq("item_id", id)
        .eq("item_type", "product");

      if (stockError) {
        console.warn(
          "‚ö†Ô∏è [DataManager] Erro ao remover itens de estoque (pode n√£o existir):",
          stockError,
        );
        // Continue with product deletion even if stock removal fails
      } else {
        console.log("‚úÖ [DataManager] Itens de estoque removidos com sucesso");
      }

      // Then delete the product
      const { error: productError } = await this.supabase
        .from("products")
        .delete()
        .eq("id", id);

      if (productError) {
        console.error(
          "‚ùå [DataManager] Erro ao deletar produto:",
          productError,
        );
        return false;
      }

      console.log(
        "‚úÖ [DataManager] Produto deletado permanentemente com sucesso",
      );
      return true;
    } catch (error) {
      console.error("‚ùå [DataManager] Erro cr√≠tico ao deletar produto:", error);
      return false;
    }
  }

  async saveEmployee(
    employee: Omit<Employee, "id" | "created_at" | "updated_at">,
  ): Promise<Employee | null> {
    return this.saveToDatabase("employees", {
      ...employee,
      id: `temp_${Date.now()}`,
    });
  }

  async loadEmployees(): Promise<Employee[]> {
    return this.loadFromDatabase<Employee>("employees");
  }

  async updateEmployee(
    id: string,
    updates: Partial<Employee>,
  ): Promise<Employee | null> {
    return this.saveToDatabase("employees", { ...updates, id });
  }

  async saveCustomer(
    customer: Omit<Customer, "id" | "created_at" | "updated_at">,
  ): Promise<Customer | null> {
    return this.saveToDatabase("customers", {
      ...customer,
      id: `temp_${Date.now()}`,
    });
  }

  async loadCustomers(): Promise<Customer[]> {
    return this.loadFromDatabase<Customer>("customers");
  }

  async updateCustomer(
    id: string,
    updates: Partial<Customer>,
  ): Promise<Customer | null> {
    return this.saveToDatabase("customers", { ...updates, id });
  }

  async saveSupplier(
    supplier: Omit<Supplier, "id" | "created_at" | "updated_at">,
  ): Promise<Supplier | null> {
    return this.saveToDatabase("suppliers", {
      ...supplier,
      id: `temp_${Date.now()}`,
    });
  }

  async loadSuppliers(): Promise<Supplier[]> {
    return this.loadFromDatabase<Supplier>("suppliers");
  }

  async updateSupplier(
    id: string,
    updates: Partial<Supplier>,
  ): Promise<Supplier | null> {
    return this.saveToDatabase("suppliers", { ...updates, id });
  }

  async saveStockItem(
    stockItem: Omit<StockItem, "id" | "created_at">,
  ): Promise<StockItem | null> {
    try {
      // Remove fields that don't exist in the stock_items table
      const {
        last_updated,
        updated_at, // This field doesn't exist in stock_items table
        ...dataToSave
      } = stockItem;

      // Validar tipos aceitos
      const validItemTypes = ["material", "product", "resaleProduct"];
      if (!validItemTypes.includes(dataToSave.item_type)) {
        console.warn(`‚ö†Ô∏è [DataManager] Tipo de item n√£o reconhecido: ${dataToSave.item_type}, convertendo para 'product'`);
        dataToSave.item_type = "product";
      }

      console.log(
        `üîß [DataManager] Inserindo stock item com dados:`,
        dataToSave,
      );

      const { data: insertedData, error } = await this.supabase
        .from("stock_items")
        .insert([dataToSave])
        .select()
        .single();

      if (error) {
        console.error(
          `‚ùå [DataManager] Erro detalhado ao inserir stock item:`,
          {
            error,
            dataToSave,
            originalStockItem: stockItem,
          },
        );
        throw error;
      }

      console.log(
        `‚úÖ [DataManager] Stock item inserido com sucesso:`,
        insertedData,
      );
      return insertedData;
    } catch (error) {
      console.error(`‚ùå [DataManager] Erro ao salvar stock item:`, error);
      return null;
    }
  }

  async loadStockItems(): Promise<StockItem[]> {
    return this.loadFromDatabase<StockItem>("stock_items");
  }

  async updateStockItem(
    id: string,
    updates: Partial<StockItem>,
  ): Promise<StockItem | null> {
    try {
      // First, check if the stock item exists
      const { data: existingItem, error: checkError } = await this.supabase
        .from("stock_items")
        .select("id, item_name, quantity")
        .eq("id", id)
        .single();

      if (checkError) {
        console.error(
          `‚ùå [DataManager] Erro ao verificar se stock item existe:`,
          {
            id,
            errorMessage: checkError.message,
            errorCode: checkError.code,
            errorDetails: checkError.details,
          },
        );
        throw new Error(
          `Stock item com ID ${id} n√£o encontrado: ${checkError.message}`,
        );
      }

      if (!existingItem) {
        console.error(`‚ùå [DataManager] Stock item n√£o encontrado:`, { id });
        throw new Error(`Stock item com ID ${id} n√£o encontrado`);
      }

      console.log(`‚úÖ [DataManager] Stock item encontrado:`, existingItem);

      // Create a clean object with only allowed fields for stock_items table
      const dataToUpdate: any = {};

      // Only include fields that exist in the stock_items table
      const allowedFields = [
        "item_id",
        "item_name",
        "item_type",
        "unit",
        "quantity",
        "unit_cost",
        "total_value",
        "min_level",
        "max_level",
        "last_updated",
      ];

      // Explicitly filter out any forbidden fields
      const forbiddenFields = ["updated_at", "created_at", "id"];

      Object.keys(updates).forEach((key) => {
        // Skip forbidden fields completely
        if (forbiddenFields.includes(key)) {
          console.warn(`üö´ [DataManager] Skipping forbidden field: ${key}`);
          return;
        }

        // Only include allowed fields with defined values
        if (
          allowedFields.includes(key) &&
          updates[key as keyof StockItem] !== undefined &&
          updates[key as keyof StockItem] !== null
        ) {
          dataToUpdate[key] = updates[key as keyof StockItem];
        }
      });

      console.log(`üîß [DataManager] Atualizando stock item ${id} com dados:`, {
        originalUpdates: updates,
        dataToUpdate,
        allowedFields,
        forbiddenFields,
        filteredOutFields: Object.keys(updates).filter(
          (key) =>
            !allowedFields.includes(key) || forbiddenFields.includes(key),
        ),
        hasDataToUpdate: Object.keys(dataToUpdate).length > 0,
        dataToUpdateKeys: Object.keys(dataToUpdate),
        dataToUpdateValues: Object.values(dataToUpdate),
      });

      // Validate that we have data to update
      if (Object.keys(dataToUpdate).length === 0) {
        console.warn(
          `‚ö†Ô∏è [DataManager] Nenhum dado v√°lido para atualizar no stock item ${id}`,
        );
        console.warn(`‚ö†Ô∏è [DataManager] Updates originais:`, updates);
        console.warn(`‚ö†Ô∏è [DataManager] Campos permitidos:`, allowedFields);
        return null;
      }

      // Validate that the ID exists and is not empty
      if (!id || id.trim() === "") {
        console.error(
          `‚ùå [DataManager] ID inv√°lido para atualizar stock item:`,
          { id, type: typeof id },
        );
        return null;
      }

      console.log(
        `üöÄ [DataManager] Executando query Supabase para stock item ${id}...`,
      );

      // Double-check that no forbidden fields made it through
      forbiddenFields.forEach((field) => {
        if (dataToUpdate.hasOwnProperty(field)) {
          console.error(
            `‚ùå [DataManager] CRITICAL: Forbidden field ${field} found in dataToUpdate!`,
          );
          delete dataToUpdate[field];
        }
      });

      // Validate data types before sending to Supabase
      const validatedData: any = {};
      Object.entries(dataToUpdate).forEach(([key, value]) => {
        if (
          key === "quantity" ||
          key === "unit_cost" ||
          key === "total_value" ||
          key === "min_level" ||
          key === "max_level"
        ) {
          // Ensure numeric fields are numbers
          const numValue =
            typeof value === "string" ? parseFloat(value) : value;
          if (isNaN(numValue)) {
            console.error(
              `‚ùå [DataManager] Valor inv√°lido para campo num√©rico ${key}:`,
              value,
            );
            throw new Error(`Valor inv√°lido para campo ${key}: ${value}`);
          }
          validatedData[key] = numValue;
        } else {
          // String fields
          validatedData[key] = value;
        }
      });

      console.log(`üîç [DataManager] Dados validados para update:`, {
        original: dataToUpdate,
        validated: validatedData,
      });

      const { data: updatedData, error } = await this.supabase
        .from("stock_items")
        .update(validatedData)
        .eq("id", id)
        .select()
        .single();

      if (error) {
        console.error(
          `‚ùå [DataManager] Erro detalhado ao atualizar stock item:`,
          {
            errorMessage: error.message,
            errorCode: error.code,
            errorDetails: error.details,
            errorHint: error.hint,
            fullError: error,
            id,
            dataToUpdate,
            originalUpdates: updates,
            finalDataKeys: Object.keys(dataToUpdate),
            supabaseQuery: `UPDATE stock_items SET ${Object.keys(dataToUpdate)
              .map((key) => `${key} = ?`)
              .join(", ")} WHERE id = '${id}'`,
          },
        );
        throw error;
      }

      console.log(
        `‚úÖ [DataManager] Stock item atualizado com sucesso:`,
        updatedData,
      );
      return updatedData;
    } catch (error) {
      console.error(`‚ùå [DataManager] Erro ao atualizar stock item:`, {
        errorMessage: error instanceof Error ? error.message : "Unknown error",
        errorCode: (error as any)?.code,
        errorDetails: (error as any)?.details,
        errorHint: (error as any)?.hint,
        fullError: error,
        stackTrace: error instanceof Error ? error.stack : undefined,
      });
      return null;
    }
  }

  async saveRecipe(
    recipe: Omit<ProductionRecipe, "id" | "created_at" | "updated_at">,
  ): Promise<ProductionRecipe | null> {
    return this.saveToDatabase("production_recipes", {
      ...recipe,
      id: `temp_${Date.now()}`,
    });
  }

  async loadRecipes(): Promise<ProductionRecipe[]> {
    return this.loadFromDatabase<ProductionRecipe>("production_recipes");
  }

  async updateRecipe(
    id: string,
    updates: Partial<ProductionRecipe>,
  ): Promise<ProductionRecipe | null> {
    return this.saveToDatabase("production_recipes", { ...updates, id });
  }

  async saveProductionEntry(
    entry: Omit<ProductionEntry, "id" | "created_at">,
  ): Promise<ProductionEntry | null> {
    console.log("üöÄ [DataManager] IN√çCIO - saveProductionEntry chamado:", {
      entry_recebida: entry,
      production_date_original: entry.production_date,
      timestamp: new Date().toISOString()
    });

    // WORKAROUND: Add +2 days to compensate Supabase UTC conversion
    // Based on logs: sending +1 day still results in -1 day, so we need +2 days
    const originalDate = new Date(entry.production_date);
    const adjustedDate = new Date(originalDate);
    adjustedDate.setDate(originalDate.getDate() + 2);
    const adjustedDateString = `${adjustedDate.getFullYear()}-${String(adjustedDate.getMonth() + 1).padStart(2, "0")}-${String(adjustedDate.getDate()).padStart(2, "0")}`;
    
    const adjustedEntry = {
      ...entry,
      production_date: adjustedDateString
    };
    
    console.log("üíæ [DataManager] WORKAROUND APLICADO - Salvando entrada de produ√ß√£o:", {
      production_date_original: entry.production_date,
      production_date_ajustada: adjustedDateString,
      originalDate_obj: originalDate,
      adjustedDate_obj: adjustedDate,
      reason: "Workaround +2 dias para compensar convers√£o UTC do Supabase (ajustado baseado nos logs)",
      production_date_tipo: typeof adjustedDateString,
      entry_final: adjustedEntry
    });

    try {
      const result = await this.saveToDatabase("production_entries", {
        ...adjustedEntry,
        id: `temp_${Date.now()}`,
      });

      if (result) {
        console.log("‚úÖ [DataManager] Entrada de produ√ß√£o salva com sucesso:", {
          id: result.id,
          product_name: result.product_name,
          production_date: result.production_date,
          production_date_formatted: new Date(
            result.production_date,
          ).toLocaleDateString("pt-BR"),
        });
      } else {
        console.error(
          "‚ùå [DataManager] Falha ao salvar entrada de produ√ß√£o - resultado nulo",
        );
      }

      return result;
    } catch (error) {
      console.error(
        "‚ùå [DataManager] Erro cr√≠tico ao salvar entrada de produ√ß√£o:",
        error,
      );
      return null;
    }
  }

  async loadProductionEntries(): Promise<ProductionEntry[]> {
    console.log("üîÑ [DataManager] Carregando entradas de produ√ß√£o do banco...");

    try {
      const entries =
        await this.loadFromDatabase<ProductionEntry>("production_entries");

      console.log("‚úÖ [DataManager] Entradas de produ√ß√£o carregadas:", {
        total: entries.length,
        entries: entries.map((e) => ({
          id: e.id,
          product_name: e.product_name,
          production_date: e.production_date,
          production_date_formatted: new Date(
            e.production_date,
          ).toLocaleDateString("pt-BR"),
        })),
      });

      return entries;
    } catch (error) {
      console.error(
        "‚ùå [DataManager] Erro ao carregar entradas de produ√ß√£o:",
        error,
      );
      return [];
    }
  }

  async deleteProductionEntry(id: string): Promise<boolean> {
    return this.deleteFromDatabase("production_entries", id);
  }

  async saveCustomUnit(unit: string): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from("custom_units")
        .insert([{ unit_name: unit }]);

      if (error) throw error;

      console.log(`‚úÖ [DataManager] Unidade customizada salva:`, unit);
      return true;
    } catch (error) {
      console.error(
        `‚ùå [DataManager] Erro ao salvar unidade customizada:`,
        error,
      );
      return false;
    }
  }

  async loadCustomUnits(): Promise<string[]> {
    try {
      const { data, error } = await this.supabase
        .from("custom_units")
        .select("unit_name")
        .order("unit_name");

      if (error) throw error;

      const units = data?.map((item) => item.unit_name) || [];
      console.log(
        `‚úÖ [DataManager] Unidades customizadas carregadas:`,
        units.length,
      );
      return units;
    } catch (error) {
      console.error(
        `‚ùå [DataManager] Erro ao carregar unidades customizadas:`,
        error,
      );
      return [];
    }
  }

  async deleteCustomUnit(unit: string): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from("custom_units")
        .delete()
        .eq("unit_name", unit);

      if (error) throw error;

      console.log(`‚úÖ [DataManager] Unidade customizada deletada:`, unit);
      return true;
    } catch (error) {
      console.error(
        `‚ùå [DataManager] Erro ao deletar unidade customizada:`,
        error,
      );
      return false;
    }
  }

  // Fixed Costs methods
  async saveFixedCost(
    fixedCost: Omit<FixedCost, "id" | "created_at" | "updated_at">,
  ): Promise<FixedCost | null> {
    return this.saveToDatabase("fixed_costs", {
      ...fixedCost,
      id: `temp_${Date.now()}`,
    });
  }

  async loadFixedCosts(): Promise<FixedCost[]> {
    return this.loadFromDatabase<FixedCost>("fixed_costs");
  }

  async updateFixedCost(
    id: string,
    updates: Partial<FixedCost>,
  ): Promise<FixedCost | null> {
    return this.saveToDatabase("fixed_costs", { ...updates, id });
  }

  // Variable Costs methods
  async saveVariableCost(
    variableCost: Omit<VariableCost, "id" | "created_at" | "updated_at">,
  ): Promise<VariableCost | null> {
    return this.saveToDatabase("variable_costs", {
      ...variableCost,
      id: `temp_${Date.now()}`,
    });
  }

  async loadVariableCosts(): Promise<VariableCost[]> {
    return this.loadFromDatabase<VariableCost>("variable_costs");
  }

  async updateVariableCost(
    id: string,
    updates: Partial<VariableCost>,
  ): Promise<VariableCost | null> {
    return this.saveToDatabase("variable_costs", { ...updates, id });
  }

  // Cash Flow methods
  async saveCashFlowEntry(
    entry: Omit<CashFlowEntry, "id" | "created_at">,
  ): Promise<CashFlowEntry | null> {
    console.log('üí∞ [DataManager] Salvando entrada de cash flow:', {
      type: entry.type,
      category: entry.category,
      reference_name: entry.reference_name,
      amount: entry.amount,
      transaction_date: entry.transaction_date,
      timestamp: new Date().toISOString()
    });

    const result = await this.saveToDatabase("cash_flow_entries", {
      ...entry,
      id: `temp_${Date.now()}`,
    });

    if (result) {
      console.log('‚úÖ [DataManager] Entrada de cash flow salva com sucesso:', {
        id: result.id,
        type: result.type,
        category: result.category,
        amount: result.amount
      });

      // Disparar evento customizado para notificar sobre nova entrada de cash flow
      const cashFlowEvent = new CustomEvent('cashFlowEntryAdded', {
        detail: {
          entry: result,
          timestamp: Date.now(),
          source: 'DataManager-saveCashFlowEntry'
        }
      });
      window.dispatchEvent(cashFlowEvent);
    }

    return result;
  }

  async loadCashFlowEntries(): Promise<CashFlowEntry[]> {
    return this.loadFromDatabase<CashFlowEntry>("cash_flow_entries");
  }

  async updateCashFlowEntry(id: string, updates: Partial<CashFlowEntry>): Promise<boolean> {
    try {
      console.log('üí∞ [DataManager] Atualizando entrada de cash flow:', {
        id: id,
        updates: updates,
        timestamp: new Date().toISOString()
      });

      const success = await this.updateInDatabase("cash_flow_entries", id, updates);

      if (success) {
        console.log('‚úÖ [DataManager] Entrada de cash flow atualizada com sucesso:', {
          id: id,
          updatedFields: Object.keys(updates)
        });
      } else {
        console.error('‚ùå [DataManager] Falha ao atualizar entrada de cash flow:', id);
      }

      return success;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao atualizar entrada de cash flow:', error);
      return false;
    }
  }

  async deleteCashFlowEntry(id: string): Promise<boolean> {
    return this.deleteFromDatabase("cash_flow_entries", id);
  }

  // Salespeople methods
  async saveSalesperson(
    salesperson: Omit<Salesperson, "id" | "created_at" | "updated_at">,
  ): Promise<Salesperson | null> {
    return this.saveToDatabase("salespeople", {
      ...salesperson,
      id: `temp_${Date.now()}`,
    });
  }

  async loadSalespeople(): Promise<Salesperson[]> {
    return this.loadFromDatabase<Salesperson>("salespeople");
  }

  async updateSalesperson(
    id: string,
    updates: Partial<Salesperson>,
  ): Promise<Salesperson | null> {
    return this.saveToDatabase("salespeople", { ...updates, id });
  }

  // Defective Tire Sales methods
  async saveDefectiveTireSale(
    sale: Omit<DefectiveTireSale, "id" | "created_at">,
  ): Promise<DefectiveTireSale | null> {
    console.log(
      "üíæ [DataManager] INICIANDO salvamento de venda de pneu defeituoso:",
      {
        ...sale,
        sale_date_formatted: new Date(sale.sale_date).toLocaleDateString(
          "pt-BR",
        ),
      },
    );

    try {
      // Validate required fields
      if (
        !sale.tire_name ||
        !sale.quantity ||
        !sale.unit_price ||
        !sale.sale_value ||
        !sale.sale_date
      ) {
        throw new Error(
          "Campos obrigat√≥rios faltando na venda de pneu defeituoso",
        );
      }

      // Clean data with all required fields
      const cleanSaleData = {
        tire_name: sale.tire_name.trim(),
        quantity: Number(sale.quantity),
        unit_price: Number(sale.unit_price),
        sale_value: Number(sale.sale_value),
        description: sale.description?.trim() || null,
        sale_date: sale.sale_date,
      };

      console.log(
        "üîß [DataManager] Dados limpos para inser√ß√£o:",
        cleanSaleData,
      );

      // Validate numeric fields
      if (isNaN(cleanSaleData.quantity) || cleanSaleData.quantity <= 0) {
        throw new Error(`Quantidade inv√°lida: ${sale.quantity}`);
      }
      if (isNaN(cleanSaleData.unit_price) || cleanSaleData.unit_price <= 0) {
        throw new Error(`Pre√ßo unit√°rio inv√°lido: ${sale.unit_price}`);
      }
      if (isNaN(cleanSaleData.sale_value) || cleanSaleData.sale_value <= 0) {
        throw new Error(`Valor de venda inv√°lido: ${sale.sale_value}`);
      }

      // Validate date format
      const dateTest = new Date(cleanSaleData.sale_date);
      if (isNaN(dateTest.getTime())) {
        throw new Error(`Data de venda inv√°lida: ${sale.sale_date}`);
      }

      // Use direct Supabase insertion for better error handling
      const { data: insertedData, error } = await this.supabase
        .from("defective_tire_sales")
        .insert([cleanSaleData])
        .select()
        .single();

      if (error) {
        console.error(
          "‚ùå [DataManager] Erro detalhado ao inserir venda de pneu defeituoso:",
          {
            error,
            errorMessage: error.message,
            errorCode: error.code,
            errorDetails: error.details,
            errorHint: error.hint,
            cleanSaleData,
            originalSale: sale,
          },
        );
        throw error;
      }

      if (!insertedData) {
        throw new Error("Supabase retornou dados nulos ap√≥s inser√ß√£o");
      }

      console.log(
        "‚úÖ [DataManager] Venda de pneu defeituoso salva com SUCESSO:",
        {
          id: insertedData.id,
          tire_name: insertedData.tire_name,
          quantity: insertedData.quantity,
          unit_price: insertedData.unit_price,
          sale_value: insertedData.sale_value,
          sale_date: insertedData.sale_date,
          sale_date_formatted: new Date(
            insertedData.sale_date,
          ).toLocaleDateString("pt-BR"),
          created_at: insertedData.created_at,
        },
      );

      // Verify the data was actually saved by querying it back
      console.log(
        "üîç [DataManager] Verificando se a venda foi realmente salva...",
      );
      const { data: verificationData, error: verificationError } =
        await this.supabase
          .from("defective_tire_sales")
          .select("*")
          .eq("id", insertedData.id)
          .single();

      if (verificationError || !verificationData) {
        console.error(
          "‚ùå [DataManager] ERRO na verifica√ß√£o - venda n√£o encontrada ap√≥s inser√ß√£o:",
          {
            verificationError,
            insertedId: insertedData.id,
          },
        );
        throw new Error(
          "Venda n√£o foi encontrada ap√≥s inser√ß√£o - poss√≠vel problema de consist√™ncia",
        );
      }

      console.log(
        "‚úÖ [DataManager] VERIFICA√á√ÉO CONCLU√çDA - Venda confirmada no banco:",
        {
          id: verificationData.id,
          tire_name: verificationData.tire_name,
          quantity: verificationData.quantity,
          unit_price: verificationData.unit_price,
          sale_value: verificationData.sale_value,
          created_at: verificationData.created_at,
        },
      );

      return insertedData;
    } catch (error) {
      console.error(
        "‚ùå [DataManager] ERRO CR√çTICO ao salvar venda de pneu defeituoso:",
        {
          error: error instanceof Error ? error.message : error,
          stack: error instanceof Error ? error.stack : undefined,
          originalSale: sale,
          table: "defective_tire_sales",
        },
      );
      return null;
    }
  }

  async loadDefectiveTireSales(): Promise<DefectiveTireSale[]> {
    console.log(
      "üîÑ [DataManager] CARREGANDO vendas de pneus defeituosos do banco...",
    );

    try {
      // Use direct Supabase query for better error handling
      const { data: sales, error } = await this.supabase
        .from("defective_tire_sales")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) {
        console.error("‚ùå [DataManager] Erro detalhado ao carregar vendas:", {
          error,
          errorMessage: error.message,
          errorCode: error.code,
          errorDetails: error.details,
        });
        throw error;
      }

      const salesData = sales || [];

      console.log("‚úÖ [DataManager] Vendas de pneus defeituosos CARREGADAS:", {
        total: salesData.length,
        tabela: "defective_tire_sales",
        primeiras_vendas: salesData.slice(0, 3).map((s) => ({
          id: s.id,
          tire_name: s.tire_name,
          quantity: s.quantity,
          unit_price: s.unit_price,
          sale_value: s.sale_value,
          sale_date: s.sale_date,
          sale_date_formatted: new Date(s.sale_date).toLocaleDateString(
            "pt-BR",
          ),
          created_at: s.created_at,
        })),
      });

      // Validate data structure
      const validSales = salesData.filter((sale) => {
        const isValid =
          sale.id &&
          sale.tire_name &&
          sale.quantity &&
          sale.unit_price &&
          sale.sale_value &&
          sale.sale_date;
        if (!isValid) {
          console.warn(
            "‚ö†Ô∏è [DataManager] Venda com dados inv√°lidos encontrada:",
            sale,
          );
        }
        return isValid;
      });

      if (validSales.length !== salesData.length) {
        console.warn(
          `‚ö†Ô∏è [DataManager] ${salesData.length - validSales.length} vendas com dados inv√°lidos foram filtradas`,
        );
      }

      return validSales;
    } catch (error) {
      console.error(
        "‚ùå [DataManager] ERRO CR√çTICO ao carregar vendas de pneus defeituosos:",
        {
          error: error instanceof Error ? error.message : error,
          stack: error instanceof Error ? error.stack : undefined,
        },
      );
      return [];
    }
  }

  async deleteDefectiveTireSale(id: string): Promise<boolean> {
    return this.deleteFromDatabase("defective_tire_sales", id);
  }

  // Cost Simulation methods
  async saveCostSimulation(
    simulation: Omit<CostSimulation, "id" | "created_at" | "updated_at">,
  ): Promise<CostSimulation | null> {
    console.log(
      "üíæ [DataManager] INICIANDO salvamento de simula√ß√£o de custo:",
      {
        name: simulation.name,
        simulation_type: simulation.simulation_type,
        cost_options: simulation.cost_options,
      },
    );

    try {
      // Validate required fields
      if (!simulation.name || !simulation.simulation_type) {
        throw new Error("Campos obrigat√≥rios faltando na simula√ß√£o de custo");
      }

      // Clean data with all required fields
      const cleanSimulationData = {
        name: simulation.name.trim(),
        description: simulation.description?.trim() || null,
        simulation_type: simulation.simulation_type,
        cost_options: simulation.cost_options,
        simulation_data: simulation.simulation_data,
        results: simulation.results || null,
      };

      console.log(
        "üîß [DataManager] Dados limpos para inser√ß√£o:",
        cleanSimulationData,
      );

      // Use direct Supabase insertion for better error handling
      const { data: insertedData, error } = await this.supabase
        .from("cost_simulations")
        .insert([cleanSimulationData])
        .select()
        .single();

      if (error) {
        console.error(
          "‚ùå [DataManager] Erro detalhado ao inserir simula√ß√£o de custo:",
          {
            error,
            errorMessage: error.message,
            errorCode: error.code,
            errorDetails: error.details,
            errorHint: error.hint,
            cleanSimulationData,
            originalSimulation: simulation,
          },
        );
        throw error;
      }

      if (!insertedData) {
        throw new Error("Supabase retornou dados nulos ap√≥s inser√ß√£o");
      }

      console.log("‚úÖ [DataManager] Simula√ß√£o de custo salva com SUCESSO:", {
        id: insertedData.id,
        name: insertedData.name,
        simulation_type: insertedData.simulation_type,
        created_at: insertedData.created_at,
      });

      return insertedData;
    } catch (error) {
      console.error(
        "‚ùå [DataManager] ERRO CR√çTICO ao salvar simula√ß√£o de custo:",
        {
          error: error instanceof Error ? error.message : error,
          stack: error instanceof Error ? error.stack : undefined,
          originalSimulation: simulation,
          table: "cost_simulations",
        },
      );
      return null;
    }
  }

  async loadCostSimulations(): Promise<CostSimulation[]> {
    console.log("üîÑ [DataManager] CARREGANDO simula√ß√µes de custo do banco...");

    try {
      // Use direct Supabase query for better error handling
      const { data: simulations, error } = await this.supabase
        .from("cost_simulations")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) {
        console.error(
          "‚ùå [DataManager] Erro detalhado ao carregar simula√ß√µes:",
          {
            error,
            errorMessage: error.message,
            errorCode: error.code,
            errorDetails: error.details,
          },
        );
        throw error;
      }

      const simulationsData = simulations || [];

      console.log("‚úÖ [DataManager] Simula√ß√µes de custo CARREGADAS:", {
        total: simulationsData.length,
        tabela: "cost_simulations",
        primeiras_simulacoes: simulationsData.slice(0, 3).map((s) => ({
          id: s.id,
          name: s.name,
          simulation_type: s.simulation_type,
          created_at: s.created_at,
        })),
      });

      // Validate data structure
      const validSimulations = simulationsData.filter((simulation) => {
        const isValid =
          simulation.id &&
          simulation.name &&
          simulation.simulation_type &&
          simulation.cost_options &&
          simulation.simulation_data;
        if (!isValid) {
          console.warn(
            "‚ö†Ô∏è [DataManager] Simula√ß√£o com dados inv√°lidos encontrada:",
            simulation,
          );
        }
        return isValid;
      });

      if (validSimulations.length !== simulationsData.length) {
        console.warn(
          `‚ö†Ô∏è [DataManager] ${simulationsData.length - validSimulations.length} simula√ß√µes com dados inv√°lidos foram filtradas`,
        );
      }

      return validSimulations;
    } catch (error) {
      console.error(
        "‚ùå [DataManager] ERRO CR√çTICO ao carregar simula√ß√µes de custo:",
        {
          error: error instanceof Error ? error.message : error,
          stack: error instanceof Error ? error.stack : undefined,
        },
      );
      return [];
    }
  }

  async updateCostSimulation(
    id: string,
    updates: Partial<CostSimulation>,
  ): Promise<CostSimulation | null> {
    console.log("üîÑ [DataManager] ATUALIZANDO simula√ß√£o de custo:", {
      id,
      updates,
    });

    try {
      // Remove fields that shouldn't be updated
      const { id: _, created_at, ...dataToUpdate } = updates;

      // Clean the data
      const cleanUpdates: any = {};
      Object.keys(dataToUpdate).forEach((key) => {
        if (dataToUpdate[key as keyof CostSimulation] !== undefined) {
          cleanUpdates[key] = dataToUpdate[key as keyof CostSimulation];
        }
      });

      if (Object.keys(cleanUpdates).length === 0) {
        console.warn(
          `‚ö†Ô∏è [DataManager] Nenhum dado v√°lido para atualizar na simula√ß√£o ${id}`,
        );
        return null;
      }

      const { data: updatedData, error } = await this.supabase
        .from("cost_simulations")
        .update(cleanUpdates)
        .eq("id", id)
        .select()
        .single();

      if (error) {
        console.error(
          "‚ùå [DataManager] Erro detalhado ao atualizar simula√ß√£o de custo:",
          {
            error,
            errorMessage: error.message,
            errorCode: error.code,
            errorDetails: error.details,
            id,
            cleanUpdates,
            originalUpdates: updates,
          },
        );
        throw error;
      }

      console.log(
        "‚úÖ [DataManager] Simula√ß√£o de custo atualizada com sucesso:",
        updatedData,
      );
      return updatedData;
    } catch (error) {
      console.error(
        "‚ùå [DataManager] ERRO CR√çTICO ao atualizar simula√ß√£o de custo:",
        {
          error: error instanceof Error ? error.message : error,
          stack: error instanceof Error ? error.stack : undefined,
          id,
          updates,
        },
      );
      return null;
    }
  }

  async deleteCostSimulation(id: string): Promise<boolean> {
    console.log("üóëÔ∏è [DataManager] DELETANDO simula√ß√£o de custo:", id);
    return this.deleteFromDatabase("cost_simulations", id);
  }

  // Resale Products methods
  async saveResaleProduct(
    resaleProduct: Omit<ResaleProduct, "id" | "created_at" | "updated_at">,
  ): Promise<ResaleProduct | null> {
    return this.saveToDatabase("resale_products", {
      ...resaleProduct,
      id: `temp_${Date.now()}`,
    });
  }

  async loadResaleProducts(): Promise<ResaleProduct[]> {
    return this.loadFromDatabase<ResaleProduct>("resale_products");
  }

  async updateResaleProduct(
    id: string,
    updates: Partial<ResaleProduct>,
  ): Promise<ResaleProduct | null> {
    return this.saveToDatabase("resale_products", { ...updates, id });
  }

  // Warranty Entry methods
  async saveWarrantyEntry(
    warrantyEntry: Omit<WarrantyEntry, "id" | "created_at">,
  ): Promise<WarrantyEntry | null> {
    console.log(
      "üíæ [DataManager] INICIANDO salvamento de entrada de garantia:",
      {
        customer_name: warrantyEntry.customer_name,
        product_name: warrantyEntry.product_name,
        quantity: warrantyEntry.quantity,
        warranty_date: warrantyEntry.warranty_date,
        warranty_date_formatted: new Date(
          warrantyEntry.warranty_date,
        ).toLocaleDateString("pt-BR"),
      },
    );

    try {
      // Validate required fields
      if (
        !warrantyEntry.customer_id ||
        !warrantyEntry.customer_name ||
        !warrantyEntry.product_name ||
        !warrantyEntry.salesperson_name ||
        !warrantyEntry.quantity ||
        !warrantyEntry.warranty_date
      ) {
        throw new Error("Campos obrigat√≥rios faltando na entrada de garantia");
      }

      // Clean data with all required fields
      const cleanWarrantyData = {
        customer_id: warrantyEntry.customer_id.trim(),
        customer_name: warrantyEntry.customer_name.trim(),
        product_name: warrantyEntry.product_name.trim(),
        salesperson_name: warrantyEntry.salesperson_name.trim(),
        quantity: Number(warrantyEntry.quantity),
        warranty_date: warrantyEntry.warranty_date,
        description: warrantyEntry.description?.trim() || null,
      };

      console.log(
        "üîß [DataManager] Dados limpos para inser√ß√£o:",
        cleanWarrantyData,
      );

      // Validate numeric fields
      if (
        isNaN(cleanWarrantyData.quantity) ||
        cleanWarrantyData.quantity <= 0
      ) {
        throw new Error(`Quantidade inv√°lida: ${warrantyEntry.quantity}`);
      }

      // Validate date format
      const dateTest = new Date(cleanWarrantyData.warranty_date);
      if (isNaN(dateTest.getTime())) {
        throw new Error(
          `Data de garantia inv√°lida: ${warrantyEntry.warranty_date}`,
        );
      }

      // Use direct Supabase insertion for better error handling
      const { data: insertedData, error } = await this.supabase
        .from("warranty_entries")
        .insert([cleanWarrantyData])
        .select()
        .single();

      if (error) {
        console.error(
          "‚ùå [DataManager] Erro detalhado ao inserir entrada de garantia:",
          {
            error,
            errorMessage: error.message,
            errorCode: error.code,
            errorDetails: error.details,
            errorHint: error.hint,
            cleanWarrantyData,
            originalWarrantyEntry: warrantyEntry,
          },
        );
        throw error;
      }

      if (!insertedData) {
        throw new Error("Supabase retornou dados nulos ap√≥s inser√ß√£o");
      }

      console.log("‚úÖ [DataManager] Entrada de garantia salva com SUCESSO:", {
        id: insertedData.id,
        customer_name: insertedData.customer_name,
        product_name: insertedData.product_name,
        salesperson_name: insertedData.salesperson_name,
        quantity: insertedData.quantity,
        warranty_date: insertedData.warranty_date,
        warranty_date_formatted: new Date(
          insertedData.warranty_date,
        ).toLocaleDateString("pt-BR"),
        created_at: insertedData.created_at,
      });

      // Verify the data was actually saved by querying it back
      console.log(
        "üîç [DataManager] Verificando se a garantia foi realmente salva...",
      );
      const { data: verificationData, error: verificationError } =
        await this.supabase
          .from("warranty_entries")
          .select("*")
          .eq("id", insertedData.id)
          .single();

      if (verificationError || !verificationData) {
        console.error(
          "‚ùå [DataManager] ERRO na verifica√ß√£o - garantia n√£o encontrada ap√≥s inser√ß√£o:",
          {
            verificationError,
            insertedId: insertedData.id,
          },
        );
        throw new Error(
          "Garantia n√£o foi encontrada ap√≥s inser√ß√£o - poss√≠vel problema de consist√™ncia",
        );
      }

      console.log(
        "‚úÖ [DataManager] VERIFICA√á√ÉO CONCLU√çDA - Garantia confirmada no banco:",
        {
          id: verificationData.id,
          customer_name: verificationData.customer_name,
          product_name: verificationData.product_name,
          quantity: verificationData.quantity,
          warranty_date: verificationData.warranty_date,
          created_at: verificationData.created_at,
        },
      );

      return insertedData;
    } catch (error) {
      console.error(
        "‚ùå [DataManager] ERRO CR√çTICO ao salvar entrada de garantia:",
        {
          error: error instanceof Error ? error.message : error,
          stack: error instanceof Error ? error.stack : undefined,
          originalWarrantyEntry: warrantyEntry,
          table: "warranty_entries",
        },
      );
      return null;
    }
  }

  async loadWarrantyEntries(): Promise<WarrantyEntry[]> {
    console.log("üîÑ [DataManager] CARREGANDO entradas de garantia do banco...");

    try {
      // Use direct Supabase query for better error handling
      const { data: warranties, error } = await this.supabase
        .from("warranty_entries")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) {
        console.error(
          "‚ùå [DataManager] Erro detalhado ao carregar garantias:",
          {
            error,
            errorMessage: error.message,
            errorCode: error.code,
            errorDetails: error.details,
          },
        );
        throw error;
      }

      const warrantiesData = warranties || [];

      console.log("‚úÖ [DataManager] Entradas de garantia CARREGADAS:", {
        total: warrantiesData.length,
        tabela: "warranty_entries",
        primeiras_garantias: warrantiesData.slice(0, 3).map((w) => ({
          id: w.id,
          customer_name: w.customer_name,
          product_name: w.product_name,
          salesperson_name: w.salesperson_name,
          quantity: w.quantity,
          warranty_date: w.warranty_date,
          warranty_date_formatted: new Date(w.warranty_date).toLocaleDateString(
            "pt-BR",
          ),
          created_at: w.created_at,
        })),
      });

      // Validate data structure
      const validWarranties = warrantiesData.filter((warranty) => {
        const isValid =
          warranty.id &&
          warranty.customer_id &&
          warranty.customer_name &&
          warranty.product_name &&
          warranty.salesperson_name &&
          warranty.quantity &&
          warranty.warranty_date;
        if (!isValid) {
          console.warn(
            "‚ö†Ô∏è [DataManager] Garantia com dados inv√°lidos encontrada:",
            warranty,
          );
        }
        return isValid;
      });

      if (validWarranties.length !== warrantiesData.length) {
        console.warn(
          `‚ö†Ô∏è [DataManager] ${warrantiesData.length - validWarranties.length} garantias com dados inv√°lidos foram filtradas`,
        );
      }

      return validWarranties;
    } catch (error) {
      console.error(
        "‚ùå [DataManager] ERRO CR√çTICO ao carregar entradas de garantia:",
        {
          error: error instanceof Error ? error.message : error,
          stack: error instanceof Error ? error.stack : undefined,
        },
      );
      return [];
    }
  }

  async deleteWarrantyEntry(id: string): Promise<boolean> {
    console.log("üóëÔ∏è [DataManager] DELETANDO entrada de garantia:", id);
    return this.deleteFromDatabase("warranty_entries", id);
  }

  async loadWarrantyEntriesByCustomer(
    customerId: string,
  ): Promise<WarrantyEntry[]> {
    try {
      const { data, error } = await this.supabase
        .from("warranty_entries")
        .select("*")
        .eq("customer_id", customerId)
        .order("created_at", { ascending: false });

      if (error) throw error;

      console.log(
        `‚úÖ [DataManager] Garantias do cliente ${customerId} carregadas:`,
        data?.length || 0,
      );
      return data || [];
    } catch (error) {
      console.error(
        `‚ùå [DataManager] Erro ao carregar garantias do cliente ${customerId}:`,
        error,
      );
      return [];
    }
  }

  // Legacy localStorage methods for backward compatibility
  saveData<T>(key: string, data: T): boolean {
    try {
      const serializedData = JSON.stringify(data);
      localStorage.setItem(key, serializedData);
      localStorage.setItem(`${key}_backup`, serializedData);
      localStorage.setItem(`${key}_timestamp`, new Date().toISOString());

      console.log(`‚úÖ [DataManager] Dados salvos localmente: ${key}`);
      this.notifyListeners(key);
      return true;
    } catch (error) {
      console.error(
        `‚ùå [DataManager] Erro ao salvar localmente ${key}:`,
        error,
      );
      return false;
    }
  }

  loadData<T>(key: string, defaultValue: T): T {
    try {
      let savedData = localStorage.getItem(key);

      if (!savedData) {
        savedData = localStorage.getItem(`${key}_backup`);
        if (savedData) {
          console.warn(`‚ö†Ô∏è [DataManager] Usando backup para ${key}`);
        }
      }

      if (savedData) {
        const parsedData = JSON.parse(savedData);
        console.log(`‚úÖ [DataManager] Dados carregados localmente: ${key}`);
        return parsedData;
      }
    } catch (error) {
      console.error(
        `‚ùå [DataManager] Erro ao carregar localmente ${key}:`,
        error,
      );
    }

    console.log(`üÜï [DataManager] Usando valor padr√£o para ${key}`);
    return defaultValue;
  }

  // Subscribe to data changes
  subscribe(key: string, callback: () => void): () => void {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, new Set());
    }
    this.listeners.get(key)!.add(callback);

    // Return unsubscribe function
    return () => {
      this.listeners.get(key)?.delete(callback);
    };
  }

  // Notify listeners of data changes
  private notifyListeners(key: string): void {
    const listeners = this.listeners.get(key);
    if (listeners) {
      listeners.forEach((callback) => {
        try {
          callback();
        } catch (error) {
          console.error(
            `‚ùå [DataManager] Erro no listener para ${key}:`,
            error,
          );
        }
      });
    }
  }

  // Get all stored keys
  getAllKeys(): string[] {
    const keys: string[] = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (
        key &&
        key.startsWith("tire-factory-") &&
        !key.includes("_backup") &&
        !key.includes("_timestamp")
      ) {
        keys.push(key);
      }
    }
    return keys;
  }

  // Export all data
  exportAllData(): Record<string, any> {
    const allData: Record<string, any> = {};
    const keys = this.getAllKeys();

    keys.forEach((key) => {
      try {
        const data = localStorage.getItem(key);
        if (data) {
          allData[key] = JSON.parse(data);
        }
      } catch (error) {
        console.error(`‚ùå [DataManager] Erro ao exportar ${key}:`, error);
      }
    });

    return allData;
  }

  // Import all data
  importAllData(data: Record<string, any>): boolean {
    try {
      Object.entries(data).forEach(([key, value]) => {
        this.saveData(key, value);
      });
      console.log(`‚úÖ [DataManager] Dados importados com sucesso`);
      return true;
    } catch (error) {
      console.error(`‚ùå [DataManager] Erro ao importar dados:`, error);
      return false;
    }
  }

  // Clear all data
  clearAllData(): void {
    const keys = this.getAllKeys();
    keys.forEach((key) => {
      localStorage.removeItem(key);
      localStorage.removeItem(`${key}_backup`);
      localStorage.removeItem(`${key}_timestamp`);
    });
    console.log(`üóëÔ∏è [DataManager] Todos os dados foram limpos`);
  }

  // Get storage usage info
  getStorageInfo(): { used: number; available: number; keys: string[] } {
    let used = 0;
    const keys = this.getAllKeys();

    keys.forEach((key) => {
      const data = localStorage.getItem(key);
      if (data) {
        used += data.length;
      }
    });

    // Estimate available space (localStorage limit is usually 5-10MB)
    const estimated = 5 * 1024 * 1024; // 5MB

    return {
      used,
      available: estimated - used,
      keys,
    };
  }

  /**
   * Salva o custo m√©dio por pneu no Supabase
   */
  async saveAverageTireCost(cost: number): Promise<boolean> {
    try {
      console.log(`üíæ [DataManager] Salvando custo m√©dio por pneu: R$ ${cost.toFixed(2)}`);

      const { error } = await this.supabase
        .from('system_settings')
        .upsert({
          key: 'average_tire_cost',
          value: cost.toString(),
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'key'
        });

      if (error) {
        console.error('‚ùå [DataManager] Erro ao salvar no Supabase:', error);
        return false;
      }

      console.log('‚úÖ [DataManager] Custo m√©dio por pneu salvo no Supabase com sucesso');
      return true;

    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao salvar custo m√©dio por pneu:', error);
      return false;
    }
  }

  /**
   * Busca o custo m√©dio por pneu do Supabase
   */
  async loadAverageTireCost(): Promise<number> {
    try {
      console.log('üîÑ [DataManager] Carregando custo m√©dio por pneu do Supabase...');

      const { data, error } = await this.supabase
        .from('system_settings')
        .select('value, updated_at')
        .eq('key', 'average_tire_cost')
        .single();

      if (error || !data) {
        console.warn('‚ö†Ô∏è [DataManager] Custo m√©dio por pneu n√£o encontrado no Supabase, usando valor padr√£o');
        return 101.09; // Valor padr√£o
      }

      const cost = Number(data.value) || 101.09;
      console.log(`‚úÖ [DataManager] Custo m√©dio por pneu carregado do Supabase: R$ ${cost.toFixed(2)}`);

      return cost;

    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao carregar custo m√©dio por pneu:', error);
      return 101.09; // Valor padr√£o em caso de erro
    }
  }

  /**
   * Subscreve √†s mudan√ßas do custo m√©dio por pneu em tempo real
   */
  subscribeToTireCostChanges(callback: (cost: number) => void): () => void {
    console.log('üîî [DataManager] Iniciando subscription para custo m√©dio por pneu...');

    const subscription = this.supabase
      .channel('tire-cost-realtime')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'system_settings',
          filter: 'key=eq.average_tire_cost'
        },
        (payload) => {
          console.log('üîÑ [DataManager] Mudan√ßa detectada no custo m√©dio por pneu:', payload);

          if (payload.new && typeof payload.new === 'object' && 'value' in payload.new) {
            const newCost = Number(payload.new.value) || 101.09;
            console.log(`üí∞ [DataManager] Novo custo m√©dio por pneu recebido: R$ ${newCost.toFixed(2)}`);

            // Chama callback
            callback(newCost);
          }
        }
      )
      .subscribe();

    // Retorna fun√ß√£o para cancelar subscription
    return () => {
      console.log('üîï [DataManager] Cancelando subscription do custo m√©dio por pneu');
      subscription.unsubscribe();
    };
  }

  /**
   * Salva o lucro m√©dio por pneu no Supabase e localStorage
   */
  async saveAverageTireProfit(profit: number): Promise<boolean> {
    try {
      console.log(`üí∞ [DataManager] Salvando lucro m√©dio por pneu: R$ ${profit.toFixed(2)}`);

      // Tenta salvar no Supabase usando upsert
      const { error: supabaseError } = await this.supabase
        .from('system_settings')
        .upsert({
          key: 'average_tire_profit',
          value: profit,
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'key'
        });

      if (supabaseError) {
        console.warn('‚ö†Ô∏è [DataManager] Erro ao salvar no Supabase (tabela pode n√£o existir):', supabaseError);
        console.log('üì± [DataManager] Salvando apenas no localStorage como fallback');
      } else {
        console.log('‚úÖ [DataManager] Lucro m√©dio por pneu salvo no Supabase com sucesso');
      }

      return true;

    } catch (error) {
      console.error('‚ùå [DataManager] Erro cr√≠tico ao salvar lucro m√©dio por pneu:', error);
      return false;
    }
  }
  /**
   * Busca o lucro m√©dio por pneu do Supabase com fallback para localStorage
   */
  async loadAverageTireProfit(): Promise<number> {
    try {
      console.log('üîÑ [DataManager] Carregando lucro m√©dio por pneu do Supabase...');

      // Tenta carregar do Supabase primeiro
      const { data, error } = await this.supabase
        .from('system_settings')
        .select('value, updated_at')
        .eq('key', 'average_tire_profit')
        .single();

      if (!error && data && data.value !== null) {
        const profit = Number(data.value);
        if (!isNaN(profit) && profit > 0) {
          console.log(`‚úÖ [DataManager] Lucro m√©dio por pneu carregado do Supabase: R$ ${profit.toFixed(2)}`);
          return profit;
        }
      }

      console.warn('‚ö†Ô∏è [DataManager] Supabase n√£o retornou valor v√°lido, usando valor padr√£o');
      return 78.77; // Valor padr√£o
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao carregar lucro m√©dio por pneu:', error);
      return 78.77; // Valor padr√£o em caso de erro
    }
  }

  /**
   * Configura subscription em tempo real para mudan√ßas no lucro m√©dio por pneu
  subscribeToTireProfitChanges(callback: (newProfit: number) => void): () => void {
    console.log('üîî [DataManager] Iniciando subscription para lucro m√©dio por pneu...');

    const subscription = this.supabase
      .channel('tire_profit_changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'system_settings',
          filter: 'key=eq.average_tire_profit'
        },
        (payload) => {
          console.log('üîÑ [DataManager] Mudan√ßa detectada no lucro m√©dio por pneu:', payload);

          if (payload.new && typeof payload.new === 'object' && 'value' in payload.new) {
            const newProfit = Number(payload.new.value) || 78.77;
            console.log(`üì° [DataManager] Novo lucro m√©dio por pneu recebido: R$ ${newProfit.toFixed(2)}`);

            // Chama callback
            callback(newProfit);
          }
        }
      )
      .subscribe();

    // Retorna fun√ß√£o para cancelar subscription
    return () => {
      console.log('üîï [DataManager] Cancelando subscription do lucro m√©dio por pneu');
      subscription.unsubscribe();
    };
  }

  /**
   * Salva o lucro m√©dio de produtos de revenda no Supabase e localStorage
   */
  async saveAverageResaleProfit(profit: number): Promise<boolean> {
    try {
      console.log(`üí∞ [DataManager] Salvando lucro m√©dio de produtos de revenda: R$ ${profit.toFixed(2)}`);

      // Tenta salvar no Supabase usando upsert
      const { error: supabaseError } = await this.supabase
        .from('system_settings')
        .upsert({
          key: 'average_resale_profit',
          value: profit,
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'key'
        });

      if (supabaseError) {
        console.warn('‚ö†Ô∏è [DataManager] Erro ao salvar no Supabase (tabela pode n√£o existir):', supabaseError);
        console.log('üì± [DataManager] Salvando apenas no localStorage como fallback');
      } else {
        console.log('‚úÖ [DataManager] Lucro m√©dio de produtos de revenda salvo no Supabase com sucesso');
      }

      return true;

    } catch (error) {
      console.error('‚ùå [DataManager] Erro cr√≠tico ao salvar lucro m√©dio de produtos de revenda:', error);
      return false;
    }
  }

  /**
   * Salva o lucro m√©dio de produtos de revenda apenas no Supabase (sem localStorage)
   */
  async saveAverageResaleProfit(profit: number): Promise<boolean> {
    try {
      console.log(`üíæ [DataManager] Salvando lucro m√©dio de produtos de revenda: R$ ${profit.toFixed(2)}`);

      const { error } = await this.supabase
        .from('system_settings')
        .upsert({
          key: 'average_resale_profit',
          value: profit.toString(),
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'key'
        });

      if (error) {
        console.error('‚ùå [DataManager] Erro ao salvar no Supabase:', error);
        return false;
      }

      console.log('‚úÖ [DataManager] Lucro m√©dio de produtos de revenda salvo no Supabase com sucesso');
      return true;

    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao salvar lucro m√©dio de produtos de revenda:', error);
      return false;
    }
  }

  /**
   * Busca o lucro m√©dio de produtos de revenda apenas do Supabase (sem localStorage)
   */
  async loadAverageResaleProfit(): Promise<number> {
    try {
      console.log('üîÑ [DataManager] Carregando lucro m√©dio de produtos de revenda do Supabase...');

      const { data, error } = await this.supabase
        .from('system_settings')
        .select('value, updated_at')
        .eq('key', 'average_resale_profit')
        .single();

      if (error) {
        console.warn('‚ö†Ô∏è [DataManager] Erro ao carregar do Supabase:', error.message);
        return 0; // Valor padr√£o
      }

      const profit = Number(data.value) || 0;
      console.log(`‚úÖ [DataManager] Lucro m√©dio de produtos de revenda carregado do Supabase: R$ ${profit.toFixed(2)}`);

      return profit;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao carregar lucro m√©dio de produtos de revenda:', error);
      return 0; // Valor padr√£o em caso de erro
    }
  }

  /**
   * Configura subscription em tempo real para mudan√ßas no lucro m√©dio de produtos de revenda
   */
  subscribeToResaleProfitChanges(callback: (newProfit: number) => void): () => void {
    console.log('üîî [DataManager] Iniciando subscription para lucro m√©dio de produtos de revenda...');

    const subscription = this.supabase
      .channel('resale_profit_changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'system_settings',
          filter: 'key=eq.average_resale_profit'
        },
        (payload) => {
          console.log('üîÑ [DataManager] Mudan√ßa detectada no lucro m√©dio de produtos de revenda:', payload);

          if (payload.new && typeof payload.new === 'object' && 'value' in payload.new) {
            const newProfit = Number(payload.new.value) || 23.61;
            console.log(`üì° [DataManager] Novo lucro m√©dio de produtos de revenda recebido: R$ ${newProfit.toFixed(2)}`);

            // Chama callback
            callback(newProfit);
          }
        }
      )
      .subscribe();

    // Retorna fun√ß√£o para cancelar subscription
    return () => {
      console.log('üîï [DataManager] Cancelando subscription do lucro m√©dio de produtos de revenda');
      subscription.unsubscribe();
    };
  }

  /**
   * Salva uma configura√ß√£o gen√©rica do sistema no Supabase
   */
  async saveSystemSetting(key: string, value: any): Promise<boolean> {
    try {
      console.log(`üíæ [DataManager] Salvando configura√ß√£o do sistema: ${key} = ${value}`);

      const { error } = await this.supabase
        .from('system_settings')
        .upsert({
          key: key,
          value: value.toString(),
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'key'
        });

      if (error) {
        console.error('‚ùå [DataManager] Erro ao salvar configura√ß√£o no Supabase:', error);
        return false;
      }

      console.log(`‚úÖ [DataManager] Configura√ß√£o ${key} salva no Supabase com sucesso`);
      return true;

    } catch (error) {
      console.error(`‚ùå [DataManager] Erro ao salvar configura√ß√£o ${key}:`, error);
      return false;
    }
  }

  /**
   * Busca uma configura√ß√£o gen√©rica do sistema do Supabase
   */
  async loadSystemSetting(key: string, defaultValue: any = null): Promise<any> {
    try {
      console.log(`üîÑ [DataManager] Carregando configura√ß√£o do sistema: ${key}`);

      const { data, error } = await this.supabase
        .from('system_settings')
        .select('value, updated_at')
        .eq('key', key)
        .single();

      if (error || !data) {
        console.warn(`‚ö†Ô∏è [DataManager] Configura√ß√£o ${key} n√£o encontrada no Supabase, usando valor padr√£o`);
        return defaultValue;
      }

      // Try to parse as number first, then string
      let value = data.value;
      const numValue = Number(value);
      if (!isNaN(numValue)) {
        value = numValue;
      }

      console.log(`‚úÖ [DataManager] Configura√ß√£o ${key} carregada do Supabase: ${value}`);
      return value;

    } catch (error) {
      console.error(`‚ùå [DataManager] Erro ao carregar configura√ß√£o ${key}:`, error);
      return defaultValue;
    }
  }

  /**
   * Subscreve √†s mudan√ßas de uma configura√ß√£o espec√≠fica do sistema em tempo real
   */
  subscribeToSystemSettingChanges(key: string, callback: (value: any) => void): () => void {
    console.log(`üîî [DataManager] Iniciando subscription para configura√ß√£o: ${key}`);

    const subscription = this.supabase
      .channel(`system_setting_${key}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'system_settings',
          filter: `key=eq.${key}`
        },
        (payload) => {
          console.log(`üîÑ [DataManager] Mudan√ßa detectada na configura√ß√£o ${key}:`, payload);

          if (payload.new && typeof payload.new === 'object' && 'value' in payload.new) {
            let value = payload.new.value;

            // Try to parse as number first, then string
            const numValue = Number(value);
            if (!isNaN(numValue)) {
              value = numValue;
            }

            console.log(`üì° [DataManager] Novo valor para ${key} recebido: ${value}`);
            callback(value);
          }
        }
      )
      .subscribe();

    // Retorna fun√ß√£o para cancelar subscription
    return () => {
      console.log(`üîï [DataManager] Cancelando subscription da configura√ß√£o: ${key}`);
      subscription.unsubscribe();
    };
  }

  /**
   * Salva o lucro m√©dio por pneu no Supabase
   */
  async saveAverageTireProfit(profit: number): Promise<boolean> {
    try {
      console.log(`üíæ [DataManager] Salvando lucro m√©dio por pneu: R$ ${profit.toFixed(2)}`);

      // Tenta salvar no Supabase
      const { error } = await this.supabase
        .from('system_settings')
        .upsert({
          key: 'average_tire_profit',
          value: profit.toString(),
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'key'
        });

      if (error) {
        console.error('‚ùå [DataManager] Erro ao salvar no Supabase (usando localStorage como fallback):', error);
        // Salva no localStorage como fallback
        localStorage.setItem('dashboard_tireProfitValue_unified', JSON.stringify({
          value: profit,
          timestamp: Date.now()
        }));
        return true; // Retorna true porque localStorage funcionou
      }

      // Tamb√©m salva no localStorage como backup
      localStorage.setItem('dashboard_tireProfitValue_unified', JSON.stringify({
        value: profit,
        timestamp: Date.now()
      }));

      console.log('‚úÖ [DataManager] Lucro m√©dio por pneu salvo no Supabase com sucesso');
      return true;

    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao salvar lucro m√©dio por pneu:', error);
      // Fallback para localStorage
      try {
        localStorage.setItem('dashboard_tireProfitValue_unified', JSON.stringify({
          value: profit,
          timestamp: Date.now()
        }));
        return true;
      } catch (localError) {
        console.error('‚ùå [DataManager] Erro tamb√©m no localStorage:', localError);
        return false;
      }
    }
  }

  /**
   * Busca o lucro m√©dio por pneu do Supabase com fallback para localStorage
   */
  async loadAverageTireProfit(): Promise<number> {
    try {
      console.log('üîÑ [DataManager] Carregando lucro m√©dio por pneu do Supabase...');

      // Tenta carregar do Supabase primeiro
      const { data, error } = await this.supabase
        .from('system_settings')
        .select('value, updated_at')
        .eq('key', 'average_tire_profit')
        .single();

      if (!error && data && data.value !== null) {
        const profit = Number(data.value);
        if (!isNaN(profit) && profit > 0) {
          console.log(`‚úÖ [DataManager] Lucro m√©dio por pneu carregado do Supabase: R$ ${profit.toFixed(2)}`);
          return profit;
        }
      }

      console.warn('‚ö†Ô∏è [DataManager] Supabase n√£o retornou valor v√°lido, tentando localStorage...');

      // Fallback para localStorage
      const localData = localStorage.getItem('dashboard_tireProfitValue_unified');
      if (localData) {
        try {
          const parsed = JSON.parse(localData);
          if (parsed && typeof parsed.value === 'number' && parsed.value > 0) {
            console.log(`‚úÖ [DataManager] Lucro m√©dio por pneu carregado do localStorage: R$ ${parsed.value.toFixed(2)}`);
            return parsed.value;
          }
        } catch (parseError) {
          console.error('‚ùå [DataManager] Erro ao parsear dados do localStorage:', parseError);
        }
      }

      console.warn('‚ö†Ô∏è [DataManager] Nenhum valor v√°lido encontrado, usando valor padr√£o');
      return 78.77; // Valor padr√£o baseado no exemplo do usu√°rio

    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao carregar lucro m√©dio por pneu:', error);

      // Fallback final para localStorage
      try {
        const localData = localStorage.getItem('dashboard_tireProfitValue_unified');
        if (localData) {
          const parsed = JSON.parse(localData);
          if (parsed && typeof parsed.value === 'number' && parsed.value > 0) {
            console.log(`‚úÖ [DataManager] Lucro m√©dio por pneu carregado do localStorage (fallback): R$ ${parsed.value.toFixed(2)}`);
            return parsed.value;
          }
        }
      } catch (fallbackError) {
        console.error('‚ùå [DataManager] Erro tamb√©m no fallback localStorage:', fallbackError);
      }

      return 78.77; // Valor padr√£o em caso de erro total
    }
  }

  /**
   * Configura subscription em tempo real para mudan√ßas no lucro m√©dio por pneu
   */
  subscribeToTireProfitChanges(callback: (newProfit: number) => void): () => void {
    console.log('üîî [DataManager] Iniciando subscription para lucro m√©dio por pneu...');

    const subscription = this.supabase
      .channel('tire_profit_changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'system_settings',
          filter: 'key=eq.average_tire_profit'
        },
        (payload) => {
          console.log('üîÑ [DataManager] Mudan√ßa detectada no lucro m√©dio por pneu:', payload);

          if (payload.new && typeof payload.new === 'object' && 'value' in payload.new) {
            const newProfit = Number(payload.new.value) || 78.77;
            console.log(`üì° [DataManager] Novo lucro m√©dio por pneu recebido: R$ ${newProfit.toFixed(2)}`);

            // Chama callback
            callback(newProfit);
          }
        }
      )
      .subscribe();

    // Retorna fun√ß√£o para cancelar subscription
    return () => {
      console.log('üîï [DataManager] Cancelando subscription do lucro m√©dio por pneu');
      subscription.unsubscribe();
    };
  }

  /**
   * Salva o saldo de produtos finais apenas no Supabase (sem localStorage)
   */
  async saveFinalProductStockBalance(balance: number): Promise<boolean> {
    try {
      console.log(`üì¶ [DataManager] Salvando saldo de produtos finais: R$ ${balance.toFixed(2)}`);

      // Salvar no Supabase usando upsert
      const { error } = await this.supabase
        .from('system_settings')
        .upsert({
          key: 'final_product_stock_balance',
          value: balance.toString(),
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'key'
        });

      if (error) {
        console.error('‚ùå [DataManager] Erro ao salvar saldo de produtos finais no Supabase:', error);
        return false;
      }

      console.log(`‚úÖ [DataManager] Saldo de produtos finais salvo com sucesso: R$ ${balance.toFixed(2)}`);
      return true;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao salvar saldo de produtos finais:', error);
      return false;
    }
  }

  /**
   * Carrega o saldo de produtos finais apenas do Supabase (sem localStorage)
   */
  async loadFinalProductStockBalance(): Promise<number> {
    try {
      console.log('üîç [DataManager] Carregando saldo de produtos finais do Supabase...');

      const { data, error } = await this.supabase
        .from('system_settings')
        .select('value')
        .eq('key', 'final_product_stock_balance')
        .single();

      if (error) {
        console.warn('‚ö†Ô∏è [DataManager] Erro ao carregar do Supabase:', error.message);
        return 0; // Valor padr√£o
      }

      const balance = Number(data.value) || 0;
      console.log(`‚úÖ [DataManager] Saldo de produtos finais carregado do Supabase: R$ ${balance.toFixed(2)}`);

      return balance;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao carregar saldo de produtos finais:', error);
      return 0; // Valor padr√£o em caso de erro
    }
  }

  /**
   * Configura subscription em tempo real para mudan√ßas no saldo de produtos finais
   */
  subscribeToFinalProductStockChanges(callback: (newBalance: number) => void): () => void {
    console.log('üîî [DataManager] Iniciando subscription para mudan√ßas no saldo de produtos finais...');

    const subscription = this.supabase
      .channel('final_product_stock_changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'system_settings',
          filter: 'key=eq.final_product_stock_balance'
        },
        (payload) => {
          console.log('üì° [DataManager] Mudan√ßa detectada no saldo de produtos finais:', payload);

          if (payload.new && payload.new.value) {
            const newBalance = Number(payload.new.value) || 0;

            if (newBalance >= 0) {
              console.log(`üí∞ [DataManager] Novo saldo de produtos finais: R$ ${newBalance.toFixed(2)}`);
              callback(newBalance);
            }
          }
        }
      )
      .subscribe();

    console.log('‚úÖ [DataManager] Subscription ativa para mudan√ßas no saldo de produtos finais');

    // Retornar fun√ß√£o de cleanup
    return () => {
      console.log('üîå [DataManager] Cancelando subscription do saldo de produtos finais');
      this.supabase.removeChannel(subscription);
    };
  }

  /**
   * Salva o saldo de mat√©ria-prima apenas no Supabase (sem localStorage)
   */
  async saveRawMaterialStockBalance(balance: number): Promise<boolean> {
    try {
      console.log(`üíæ [DataManager] Salvando saldo de mat√©ria-prima: R$ ${balance.toFixed(2)}`);

      // Salvar no Supabase usando upsert
      const { error } = await this.supabase
        .from('system_settings')
        .upsert({
          key: 'raw_material_stock_balance',
          value: balance.toString(),
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'key'
        });

      if (error) {
        console.error('‚ùå [DataManager] Erro ao salvar saldo de mat√©ria-prima no Supabase:', error);
        return false;
      }

      console.log(`‚úÖ [DataManager] Saldo de mat√©ria-prima salvo com sucesso: R$ ${balance.toFixed(2)}`);
      return true;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao salvar saldo de mat√©ria-prima:', error);
      return false;
    }
  }

  /**
   * Salva o saldo de caixa no Supabase
   */
  async saveCashBalance(balance: number): Promise<boolean> {
    try {
      console.log(`üí∞ [DataManager] Salvando saldo de caixa: R$ ${balance.toFixed(2)}`);

      // Salvar no Supabase usando upsert
      const { error } = await this.supabase
        .from('system_settings')
        .upsert({
          key: 'cash_balance',
          value: balance.toString(),
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'key'
        });

      if (error) {
        console.error('‚ùå [DataManager] Erro ao salvar saldo de caixa no Supabase:', error);
        return false;
      }

      console.log(`‚úÖ [DataManager] Saldo de caixa salvo com sucesso: R$ ${balance.toFixed(2)}`);
      return true;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao salvar saldo de caixa:', error);
      return false;
    }
  }

  /**
   * Carrega o saldo de caixa do Supabase
   */
  async loadCashBalance(): Promise<number> {
    try {
      console.log('üîç [DataManager] Carregando saldo de caixa do Supabase...');

      const { data, error } = await this.supabase
        .from('system_settings')
        .select('value')
        .eq('key', 'cash_balance')
        .single();

      if (error) {
        console.warn('‚ö†Ô∏è [DataManager] Erro ao carregar saldo de caixa do Supabase:', error.message);
        return 0; // Valor padr√£o
      }

      const balance = Number(data.value) || 0;
      console.log(`‚úÖ [DataManager] Saldo de caixa carregado do Supabase: R$ ${balance.toFixed(2)}`);

      return balance;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao carregar saldo de caixa:', error);
      return 0; // Valor padr√£o em caso de erro
    }
  }

  /**
   * Configura subscription em tempo real para mudan√ßas no saldo de caixa
   */
  subscribeToCashBalanceChanges(callback: (newBalance: number) => void): () => void {
    console.log('üîî [DataManager] Iniciando subscription para mudan√ßas no saldo de caixa...');

    const subscription = this.supabase
      .channel('cash_balance_changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'system_settings',
          filter: 'key=eq.cash_balance'
        },
        (payload) => {
          console.log('üì° [DataManager] Mudan√ßa detectada no saldo de caixa:', payload);

          if (payload.new && payload.new.value) {
            const newBalance = Number(payload.new.value) || 0;

            if (newBalance >= 0) {
              console.log(`üí∞ [DataManager] Novo saldo de caixa: R$ ${newBalance.toFixed(2)}`);
              callback(newBalance);
            }
          }
        }
      )
      .subscribe();

    console.log('‚úÖ [DataManager] Subscription ativa para mudan√ßas no saldo de caixa');

    // Retornar fun√ß√£o de cleanup
    return () => {
      console.log('üîå [DataManager] Cancelando subscription do saldo de caixa');
      this.supabase.removeChannel(subscription);
    };
  }

  /**
   * Carrega o saldo de mat√©ria-prima apenas do Supabase (sem localStorage)
   */
  async loadRawMaterialStockBalance(): Promise<number> {
    try {
      console.log('üîç [DataManager] Carregando saldo de mat√©ria-prima do Supabase...');

      const { data, error } = await this.supabase
        .from('system_settings')
        .select('value')
        .eq('key', 'raw_material_stock_balance')
        .single();

      if (error) {
        console.warn('‚ö†Ô∏è [DataManager] Erro ao carregar saldo de mat√©ria-prima do Supabase:', error.message);
        return 0; // Valor padr√£o
      }

      const balance = Number(data.value) || 0;
      console.log(`‚úÖ [DataManager] Saldo de mat√©ria-prima carregado do Supabase: R$ ${balance.toFixed(2)}`);

      return balance;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao carregar saldo de mat√©ria-prima:', error);
      return 0; // Valor padr√£o em caso de erro
    }
  }

  /**
   * Configura subscription em tempo real para mudan√ßas no saldo de mat√©ria-prima
   */
  subscribeToRawMaterialStockChanges(callback: (newBalance: number) => void): () => void {
    console.log('üîî [DataManager] Iniciando subscription para mudan√ßas no saldo de mat√©ria-prima...');

    console.log('‚ö†Ô∏è [DataManager] TEMPOR√ÅRIO: Subscription desabilitada (tabela system_settings n√£o existe)');

    // TODO: Implementar Supabase Realtime quando tabela system_settings for criada
    // Por enquanto, retornar fun√ß√£o vazia
    return () => {
      console.log('üîå [DataManager] Cleanup de subscription de mat√©ria-prima (vazia)');
    };
  }

  /**
   * Salva uma configura√ß√£o do sistema no Supabase
   */
  async saveSystemSetting(key: string, value: string): Promise<boolean> {
    try {
      console.log(`üíæ [DataManager] Salvando configura√ß√£o do sistema: ${key}`);

      const { data: existingData, error: selectError } = await this.supabase
        .from('system_settings')
        .select('id, value')
        .eq('key', key)
        .single();

      // Handle case where the table might not exist yet
      if (selectError && selectError.code === '42P01') { // '42P01' is Undefined_table error code
          console.warn(`‚ö†Ô∏è [DataManager] Tabela 'system_settings' n√£o encontrada. Tentando criar.`);
          // Attempt to create the table (this is a simplified example, actual DDL should be managed separately)
          // In a real app, you'd run migrations. For this example, we'll log a message.
          console.warn(`‚ö†Ô∏è [DataManager] Please ensure the 'system_settings' table exists with 'key' (TEXT, PRIMARY KEY), 'value' (TEXT), and 'updated_at' (TIMESTAMP WITH TIME ZONE) columns.`);
          // Proceed as if trying to insert, it might work if the table is implicitly created by some setups or will error again.
      } else if (selectError) {
          console.error(`‚ùå [DataManager] Erro ao verificar configura√ß√£o ${key}:`, selectError);
          return false;
      }

      if (existingData) {
        // Atualizar registro existente
        const { error: updateError } = await this.supabase
          .from('system_settings')
          .update({
            value: value,
            updated_at: new Date().toISOString()
          })
          .eq('key', key);

        if (updateError) {
          console.error(`‚ùå [DataManager] Erro ao atualizar configura√ß√£o ${key}:`, updateError);
          return false;
        }
      } else {
        // Inserir novo registro
        const { error: insertError } = await this.supabase
          .from('system_settings')
          .insert({
            key: key,
            value: value,
            description: `Configura√ß√£o do sistema: ${key}`,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          });

        if (insertError) {
          console.error(`‚ùå [DataManager] Erro ao inserir configura√ß√£o ${key}:`, insertError);
          return false;
        }
      }

      console.log(`‚úÖ [DataManager] Configura√ß√£o ${key} salva com sucesso`);
      return true;
    } catch (error) {
      console.error(`‚ùå [DataManager] Erro ao salvar configura√ß√£o ${key}:`, error);
      return false;
    }
  }

  /**
   * Carrega uma configura√ß√£o do sistema do Supabase
   */
  async loadSystemSetting(key: string): Promise<string | null> {
    try {
      console.log(`üîç [DataManager] Carregando configura√ß√£o do sistema: ${key}`);

      const { data, error } = await this.supabase
        .from('system_settings')
        .select('value')
        .eq('key', key)
        .single();

      if (error) {
        if (error.code === 'PGRST116') { // Not found
          console.log(`‚ö†Ô∏è [DataManager] Configura√ß√£o ${key} n√£o encontrada`);
          return null;
        }
        console.error(`‚ùå [DataManager] Erro ao carregar configura√ß√£o ${key}:`, error);
        return null;
      }

      console.log(`‚úÖ [DataManager] Configura√ß√£o ${key} carregada: ${data.value}`);
      return data.value;
    } catch (error) {
      console.error(`‚ùå [DataManager] Erro ao carregar configura√ß√£o ${key}:`, error);
      return null;
    }
  }

  // ===== PRODUCT UNIT COST METHODS =====

  /**
   * Salva o custo unit√°rio de um produto espec√≠fico no Supabase
   */
  async saveProductUnitCost(productName: string, unitCost: number): Promise<boolean> {
    try {
      const key = `product_unit_cost_${productName.toLowerCase().replace(/\s+/g, '_')}`;
      console.log(`üí∞ [DataManager] Salvando custo unit√°rio para ${productName}: R$ ${unitCost.toFixed(2)}`);

      const success = await this.saveSystemSetting(key, unitCost.toString());

      if (success) {
        // Salvar tamb√©m no localStorage para fallback
        const productKey = `tireAnalysis_${productName.toLowerCase().replace(/\s+/g, '_')}`;
        const existingData = localStorage.getItem(productKey);
        let analysisData: any = {};

        if (existingData) {
          try {
            analysisData = JSON.parse(existingData);
          } catch (e) {
            console.warn(`‚ö†Ô∏è [DataManager] Erro ao parsear dados existentes para ${productName}`);
          }
        }

        analysisData.costPerTire = unitCost;
        analysisData.lastUpdated = Date.now();
        analysisData.source = 'DataManager-saveProductUnitCost';

        localStorage.setItem(productKey, JSON.stringify(analysisData));
        console.log(`‚úÖ [DataManager] Custo unit√°rio para ${productName} salvo no Supabase e localStorage`);
      }

      return success;
    } catch (error) {
      console.error(`‚ùå [DataManager] Erro ao salvar custo unit√°rio para ${productName}:`, error);
      return false;
    }
  }

  /**
   * Carrega o custo unit√°rio de um produto espec√≠fico do Supabase
   */
  async loadProductUnitCost(productName: string): Promise<number | null> {
    try {
      const key = `product_unit_cost_${productName.toLowerCase().replace(/\s+/g, '_')}`;
      console.log(`üîç [DataManager] Carregando custo unit√°rio para ${productName}`);

      const costStr = await this.loadSystemSetting(key);

      if (costStr) {
        const cost = Number(costStr) || 0;
        console.log(`‚úÖ [DataManager] Custo unit√°rio para ${productName} carregado do Supabase: R$ ${cost.toFixed(2)}`);
        return cost;
      }

      // Fallback: tentar carregar do localStorage
      const productKey = `tireAnalysis_${productName.toLowerCase().replace(/\s+/g, '_')}`;
      const localData = localStorage.getItem(productKey);

      if (localData) {
        try {
          const analysis = JSON.parse(localData);
          if (analysis.costPerTire && analysis.costPerTire > 0) {
            console.log(`üì¶ [DataManager] Custo unit√°rio para ${productName} carregado do localStorage: R$ ${analysis.costPerTire.toFixed(2)}`);

            // Sincronizar com Supabase para pr√≥ximas consultas
            await this.saveProductUnitCost(productName, analysis.costPerTire);

            return analysis.costPerTire;
          }
        } catch (e) {
          console.warn(`‚ö†Ô∏è [DataManager] Erro ao parsear dados do localStorage para ${productName}`);
        }
      }

      console.log(`‚ö†Ô∏è [DataManager] Custo unit√°rio para ${productName} n√£o encontrado`);
      return null;
    } catch (error) {
      console.error(`‚ùå [DataManager] Erro ao carregar custo unit√°rio para ${productName}:`, error);
      return null;
    }
  }

  /**
   * Carrega todos os custos unit√°rios de produtos do Supabase
   */
  async loadAllProductUnitCosts(): Promise<{ [productName: string]: number }> {
    try {
      console.log('üîç [DataManager] Carregando todos os custos unit√°rios de produtos...');

      const { data, error } = await this.supabase
        .from('system_settings')
        .select('key, value')
        .like('key', 'product_unit_cost_%');

      if (error) {
        console.error('‚ùå [DataManager] Erro ao carregar custos unit√°rios:', error);
        return {};
      }

      const costs: { [productName: string]: number } = {};

      if (data) {
        data.forEach(item => {
          const productName = item.key.replace('product_unit_cost_', '').replace(/_/g, ' ');
          const cost = Number(item.value) || 0;
          if (cost > 0) {
            costs[productName] = cost;
          }
        });
      }

      console.log(`‚úÖ [DataManager] ${Object.keys(costs).length} custos unit√°rios carregados do Supabase`);
      return costs;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao carregar custos unit√°rios:', error);
      return {};
    }
  }

  /**
   * Configura subscription em tempo real para mudan√ßas nos custos unit√°rios
   */
  subscribeToProductCostChanges(callback: (productName: string, newCost: number) => void): () => void {
    console.log('üîî [DataManager] Iniciando subscription para mudan√ßas nos custos unit√°rios...');

    const subscription = this.supabase
      .channel('product_costs_changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'system_settings',
          filter: 'key=like.product_unit_cost_%'
        },
        (payload) => {
          console.log('üì° [DataManager] Mudan√ßa detectada nos custos unit√°rios:', payload);

          if (payload.new && payload.new.key && payload.new.value) {
            const productName = payload.new.key.replace('product_unit_cost_', '').replace(/_/g, ' ');
            const newCost = Number(payload.new.value) || 0;

            if (newCost > 0) {
              console.log(`üí∞ [DataManager] Novo custo unit√°rio para ${productName}: R$ ${newCost.toFixed(2)}`);
              callback(productName, newCost);
            }
          }
        }
      )
      .subscribe();

    console.log('‚úÖ [DataManager] Subscription ativa para mudan√ßas nos custos unit√°rios');

    // Retornar fun√ß√£o de cleanup
    return () => {
      console.log('üîå [DataManager] Cancelando subscription dos custos unit√°rios');
      this.supabase.removeChannel(subscription);
    };
  }

  // ===== FINAL PRODUCT TOTAL QUANTITY METHODS =====

  /**
   * Salva a quantidade total de produtos finais apenas no Supabase (sem localStorage)
   */
  async saveFinalProductTotalQuantity(quantity: number): Promise<boolean> {
    try {
      console.log(`üì¶ [DataManager] Salvando quantidade total de produtos finais: ${quantity}`);

      const { error } = await this.supabase
        .from('system_settings')
        .upsert({
          key: 'final_product_total_quantity',
          value: quantity.toString(),
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'key'
        });

      if (error) {
        console.error('‚ùå [DataManager] Erro ao salvar quantidade total de produtos finais no Supabase:', error);
        return false;
      }

      console.log(`‚úÖ [DataManager] Quantidade total de produtos finais salva com sucesso: ${quantity}`);
      return true;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao salvar quantidade total de produtos finais:', error);
      return false;
    }
  }

  /**
   * Carrega a quantidade total de produtos finais apenas do Supabase (sem localStorage)
   */
  async loadFinalProductTotalQuantity(): Promise<number> {
    try {
      console.log('üîç [DataManager] Carregando quantidade total de produtos finais do Supabase...');

      const { data, error } = await this.supabase
        .from('system_settings')
        .select('value')
        .eq('key', 'final_product_total_quantity')
        .single();

      if (error) {
        console.warn('‚ö†Ô∏è [DataManager] Erro ao carregar quantidade total de produtos finais do Supabase:', error.message);
        return 0; // Valor padr√£o
      }

      const quantity = Number(data.value) || 0;
      console.log(`‚úÖ [DataManager] Quantidade total de produtos finais carregada do Supabase: ${quantity}`);

      return quantity;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao carregar quantidade total de produtos finais:', error);
      return 0; // Valor padr√£o em caso de erro
    }
  }

  /**
   * Configura subscription em tempo real para mudan√ßas na quantidade total de produtos finais
   */
  subscribeToFinalProductTotalQuantityChanges(callback: (newQuantity: number) => void): () => void {
    console.log('üîî [DataManager] Iniciando subscription para mudan√ßas na quantidade total de produtos finais...');

    const subscription = this.supabase
      .channel('final_product_quantity_changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'system_settings',
          filter: 'key=eq.final_product_total_quantity'
        },
        (payload) => {
          console.log('üîÑ [DataManager] Mudan√ßa detectada na quantidade total de produtos finais:', payload);

          if (payload.new && typeof payload.new === 'object' && 'value' in payload.new) {
            const newQuantity = Number(payload.new.value) || 0;
            console.log(`üì¶ [DataManager] Nova quantidade total de produtos finais recebida: ${newQuantity}`);

            callback(newQuantity);
          }
        }
      )
      .subscribe();

    console.log('‚úÖ [DataManager] Subscription ativa para mudan√ßas na quantidade total de produtos finais');

    // Retornar fun√ß√£o de cleanup
    return () => {
      console.log('üîå [DataManager] Cancelando subscription da quantidade total de produtos finais');
      this.supabase.removeChannel(subscription);
    };
  }

  /**
   * Salva a quantidade unit√°ria de mat√©ria-prima apenas no Supabase (sem localStorage)
   */
  async saveRawMaterialUnitaryQuantity(quantity: number): Promise<boolean> {
    try {
      console.log(`üíæ [DataManager] Salvando quantidade unit√°ria de mat√©ria-prima: ${quantity}`);

      // Salvar no Supabase usando upsert
      const { error } = await this.supabase
        .from('system_settings')
        .upsert({
          key: 'raw_material_unitary_quantity',
          value: quantity.toString(),
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'key'
        });

      if (error) {
        console.error('‚ùå [DataManager] Erro ao salvar quantidade unit√°ria de mat√©ria-prima no Supabase:', error);
        return false;
      }

      console.log(`‚úÖ [DataManager] Quantidade unit√°ria de mat√©ria-prima salva com sucesso: ${quantity}`);
      return true;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao salvar quantidade unit√°ria de mat√©ria-prima:', error);
      return false;
    }
  }

  /**
   * Carrega a quantidade unit√°ria de mat√©ria-prima apenas do Supabase (sem localStorage)
   */
  async loadRawMaterialUnitaryQuantity(): Promise<number> {
    try {
      console.log('üîç [DataManager] Carregando quantidade unit√°ria de mat√©ria-prima do Supabase...');

      const { data, error } = await this.supabase
        .from('system_settings')
        .select('value')
        .eq('key', 'raw_material_unitary_quantity')
        .single();

      if (error) {
        console.warn('‚ö†Ô∏è [DataManager] Erro ao carregar quantidade unit√°ria de mat√©ria-prima do Supabase:', error.message);
        return 0; // Valor padr√£o
      }

      const quantity = Number(data.value) || 0;
      console.log(`‚úÖ [DataManager] Quantidade unit√°ria de mat√©ria-prima carregada do Supabase: ${quantity}`);

      return quantity;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao carregar quantidade unit√°ria de mat√©ria-prima:', error);
      return 0; // Valor padr√£o em caso de erro
    }
  }

  /**
   * Configura subscription em tempo real para mudan√ßas na quantidade unit√°ria de mat√©ria-prima
   */
  subscribeToRawMaterialUnitaryQuantityChanges(callback: (newQuantity: number) => void): () => void {
    console.log('üîî [DataManager] Iniciando subscription para mudan√ßas na quantidade unit√°ria de mat√©ria-prima...');

    const subscription = this.supabase
      .channel('raw_material_unitary_quantity_changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'system_settings',
          filter: 'key=eq.raw_material_unitary_quantity'
        },
        (payload) => {
          console.log('üì° [DataManager] Mudan√ßa detectada na quantidade unit√°ria de mat√©ria-prima:', payload);

          if (payload.new && payload.new.value) {
            const newQuantity = Number(payload.new.value) || 0;

            if (newQuantity >= 0) {
              console.log(`üì¶ [DataManager] Nova quantidade unit√°ria de mat√©ria-prima: ${newQuantity}`);
              callback(newQuantity);
            }
          }
        }
      )
      .subscribe();

    console.log('‚úÖ [DataManager] Subscription ativa para mudan√ßas na quantidade unit√°ria de mat√©ria-prima');

    // Retornar fun√ß√£o de cleanup
    return () => {
      console.log('üîå [DataManager] Cancelando subscription da quantidade unit√°ria de mat√©ria-prima');
      this.supabase.removeChannel(subscription);
    };
  }

  /**
   * Salva a quantidade total de produtos revenda apenas no Supabase (sem localStorage)
   */
  async saveResaleProductTotalQuantity(quantity: number): Promise<boolean> {
    try {
      console.log(`üíæ [DataManager] Salvando quantidade total de produtos revenda: ${quantity}`);

      // Salvar no Supabase usando upsert
      const { error } = await this.supabase
        .from('system_settings')
        .upsert({
          key: 'resale_product_total_quantity',
          value: quantity.toString(),
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'key'
        });

      if (error) {
        console.error('‚ùå [DataManager] Erro ao salvar quantidade total de produtos revenda no Supabase:', error);
        return false;
      }

      console.log(`‚úÖ [DataManager] Quantidade total de produtos revenda salva com sucesso: ${quantity}`);
      return true;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao salvar quantidade total de produtos revenda:', error);
      return false;
    }
  }

  /**
   * Carrega a quantidade total de produtos revenda apenas do Supabase (sem localStorage)
   */
  async loadResaleProductTotalQuantity(): Promise<number> {
    try {
      console.log('üîç [DataManager] Carregando quantidade total de produtos revenda do Supabase...');

      const { data, error } = await this.supabase
        .from('system_settings')
        .select('value')
        .eq('key', 'resale_product_total_quantity')
        .single();

      if (error) {
        console.warn('‚ö†Ô∏è [DataManager] Erro ao carregar quantidade total de produtos revenda do Supabase:', error.message);
        return 0; // Valor padr√£o
      }

      const quantity = Number(data.value) || 0;
      console.log(`‚úÖ [DataManager] Quantidade total de produtos revenda carregada do Supabase: ${quantity}`);

      return quantity;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao carregar quantidade total de produtos revenda:', error);
      return 0; // Valor padr√£o em caso de erro
    }
  }

  /**
   * Configura subscription em tempo real para mudan√ßas na quantidade total de produtos revenda
   */
  subscribeToResaleProductTotalQuantityChanges(callback: (newQuantity: number) => void): () => void {
    console.log('üîî [DataManager] Iniciando subscription para mudan√ßas na quantidade total de produtos revenda...');

    const subscription = this.supabase
      .channel('resale_product_total_quantity_changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'system_settings',
          filter: 'key=eq.resale_product_total_quantity'
        },
        (payload) => {
          console.log('üì° [DataManager] Mudan√ßa detectada na quantidade total de produtos revenda:', payload);

          if (payload.new && payload.new.value) {
            const newQuantity = Number(payload.new.value) || 0;

            if (newQuantity >= 0) {
              console.log(`üõçÔ∏è [DataManager] Nova quantidade total de produtos revenda: ${newQuantity}`);
              callback(newQuantity);
            }
          }
        }
      )
      .subscribe();

    console.log('‚úÖ [DataManager] Subscription ativa para mudan√ßas na quantidade total de produtos revenda');

    // Retornar fun√ß√£o de cleanup
    return () => {
      console.log('üîå [DataManager] Cancelando subscription da quantidade total de produtos revenda');
      this.supabase.removeChannel(subscription);
    };
  }

  // Fun√ß√£o para carregar valor empresarial
  async loadBusinessValue(): Promise<number> {
    try {
      const { data, error } = await supabase
        .from('system_settings')
        .select('value')
        .eq('key', 'business_value')
        .single();

      if (error) {
        console.warn('‚ö†Ô∏è [DataManager] Valor empresarial n√£o encontrado, usando padr√£o 0');
        return 0;
      }

      const value = parseFloat(data.value) || 0;
      console.log('‚úÖ [DataManager] Valor empresarial carregado:', value);
      return value;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao carregar valor empresarial:', error);
      return 0;
    }
  }

  // Fun√ß√£o para salvar valor empresarial
  async saveBusinessValue(value: number): Promise<boolean> {
    try {
      console.log('üíæ [DataManager] Tentando salvar valor empresarial:', value);
      
      // Primeiro, tentar atualizar o registro existente
      const { data: updateData, error: updateError } = await supabase
        .from('system_settings')
        .update({
          value: value.toString(),
          updated_at: new Date().toISOString()
        })
        .eq('key', 'business_value')
        .select();

      if (updateError) {
        console.warn('‚ö†Ô∏è [DataManager] Erro ao atualizar valor empresarial, tentando inserir:', updateError);
        
        // Se a atualiza√ß√£o falhou, tentar inserir um novo registro
        const { data: insertData, error: insertError } = await supabase
          .from('system_settings')
          .insert({
            key: 'business_value',
            value: value.toString(),
            updated_at: new Date().toISOString()
          })
          .select();

        if (insertError) {
          console.error('‚ùå [DataManager] Erro ao inserir valor empresarial:', insertError);
          return false;
        }

        console.log('‚úÖ [DataManager] Valor empresarial inserido com sucesso:', value);
      } else {
        console.log('‚úÖ [DataManager] Valor empresarial atualizado com sucesso:', value);
      }

      // IMPORTANTE: Recalcular lucro automaticamente se houver baseline
      try {
        const baseline = await this.loadBusinessValueBaseline();
        if (baseline !== null) {
          console.log('üîÑ [DataManager] Recalculando lucro empresarial ap√≥s mudan√ßa no valor...');
          await this.calculateBusinessProfit();
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è [DataManager] Erro ao recalcular lucro ap√≥s salvar valor:', error);
      }

      return true;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro cr√≠tico ao salvar valor empresarial:', error);
      return false;
    }
  }

  // Fun√ß√£o para carregar lucro empresarial
  async loadBusinessProfit(): Promise<number> {
    try {
      console.log('üìä [DataManager] Carregando lucro empresarial...');
      
      const { data, error } = await supabase
        .from('system_settings')
        .select('value')
        .eq('key', 'business_profit')
        .single();

      if (error) {
        console.warn('‚ö†Ô∏è [DataManager] Erro ao carregar lucro empresarial, usando valor padr√£o:', error);
        // Por enquanto, usar o mesmo valor do business_value como fallback
        return await this.loadBusinessValue();
      }

      const profit = parseFloat(data.value) || 0;
      console.log('‚úÖ [DataManager] Lucro empresarial carregado:', profit);
      return profit;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro cr√≠tico ao carregar lucro empresarial:', error);
      // Fallback para o valor empresarial
      return await this.loadBusinessValue();
    }
  }

  // Fun√ß√£o para salvar lucro empresarial
  async saveBusinessProfit(profit: number): Promise<boolean> {
    try {
      console.log('üíæ [DataManager] Tentando salvar lucro empresarial:', profit);
      
      // Primeiro, tentar atualizar o registro existente
      const { data: updateData, error: updateError } = await supabase
        .from('system_settings')
        .update({
          value: profit.toString(),
          updated_at: new Date().toISOString()
        })
        .eq('key', 'business_profit')
        .select();

      if (updateError) {
        console.warn('‚ö†Ô∏è [DataManager] Erro ao atualizar lucro empresarial, tentando inserir:', updateError);
        
        // Se a atualiza√ß√£o falhou, tentar inserir um novo registro
        const { data: insertData, error: insertError } = await supabase
          .from('system_settings')
          .insert({
            key: 'business_profit',
            value: profit.toString(),
            updated_at: new Date().toISOString()
          })
          .select();

        if (insertError) {
          console.error('‚ùå [DataManager] Erro ao inserir lucro empresarial:', insertError);
          return false;
        }

        console.log('‚úÖ [DataManager] Lucro empresarial inserido com sucesso:', profit);
        return true;
      }

      console.log('‚úÖ [DataManager] Lucro empresarial atualizado com sucesso:', profit);
      return true;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro cr√≠tico ao salvar lucro empresarial:', error);
      return false;
    }
  }

  // Fun√ß√£o para subscrever mudan√ßas no valor empresarial em tempo real
  subscribeToBusinessValueChanges(callback: (value: number) => void): () => void {
    console.log('üîî [DataManager] Configurando subscription para valor empresarial');

    const subscription = supabase
      .channel('business_value_changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'system_settings',
          filter: 'key=eq.business_value'
        },
        (payload) => {
          console.log('üîÑ [DataManager] Mudan√ßa detectada no valor empresarial:', payload);

          if (payload.new && 'value' in payload.new) {
            const newValue = parseFloat(payload.new.value as string) || 0;
            callback(newValue);
          }
        }
      )
      .subscribe();

    return () => {
      console.log('üîï [DataManager] Removendo subscription do valor empresarial');
      subscription.unsubscribe();
    };
  }

  // Fun√ß√£o para subscrever mudan√ßas no lucro empresarial em tempo real
  subscribeToBusinessProfitChanges(callback: (profit: number) => void): () => void {
    console.log('üîî [DataManager] Configurando subscription para lucro empresarial');

    const subscription = supabase
      .channel('business_profit_changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'system_settings',
          filter: 'key=eq.business_profit'
        },
        (payload) => {
          console.log('üîÑ [DataManager] Mudan√ßa detectada no lucro empresarial:', payload);

          if (payload.new && typeof payload.new === 'object' && 'value' in payload.new) {
            const newProfit = parseFloat(payload.new.value) || 0;
            console.log(`üì° [DataManager] Novo lucro empresarial recebido: R$ ${newProfit.toFixed(2)}`);
            callback(newProfit);
          }
        }
      )
      .subscribe();

    return () => {
      console.log('üîï [DataManager] Cancelando subscription do lucro empresarial');
      subscription.unsubscribe();
    };
  }

  // Fun√ß√£o para subscrever mudan√ßas no lucro de revenda em tempo real
  subscribeToResaleProfitChanges(callback: (profit: number) => void): () => void {
    console.log('üîî [DataManager] Iniciando subscription para lucro m√©dio de produtos de revenda...');

    const subscription = this.supabase
      .channel('resale_profit_changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'system_settings',
          filter: 'key=eq.average_resale_profit'
        },
        (payload) => {
          console.log('üîÑ [DataManager] Mudan√ßa detectada no lucro m√©dio de produtos de revenda:', payload);

          if (payload.new && typeof payload.new === 'object' && 'value' in payload.new) {
            const newProfit = Number(payload.new.value) || 23.61;
            console.log(`üì° [DataManager] Novo lucro m√©dio de produtos de revenda recebido: R$ ${newProfit.toFixed(2)}`);

            // Chama callback
            callback(newProfit);
          }
        }
      )
      .subscribe();

    // Retorna fun√ß√£o para cancelar subscription
    return () => {
      console.log('üîï [DataManager] Cancelando subscription do lucro m√©dio de produtos de revenda');
      subscription.unsubscribe();
    };
  }

  // Fun√ß√£o para salvar baseline do valor empresarial (para c√°lculo de lucro)
  async saveBusinessValueBaseline(baselineValue: number): Promise<boolean> {
    try {
      console.log('üíæ [DataManager] Salvando baseline do valor empresarial:', baselineValue);
      
      // Usar upsert para inserir ou atualizar automaticamente
      const { data, error } = await this.supabase
        .from('system_settings')
        .upsert({
          key: 'business_value_baseline',
          value: baselineValue.toString(),
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'key'
        })
        .select();

      if (error) {
        console.error('‚ùå [DataManager] Erro ao salvar baseline do valor empresarial:', error);
        return false;
      }

      console.log('‚úÖ [DataManager] Baseline do valor empresarial salvo com sucesso:', baselineValue);
      console.log('üìä [DataManager] Dados salvos:', data);
      return true;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro cr√≠tico ao salvar baseline do valor empresarial:', error);
      return false;
    }
  }

  // Fun√ß√£o para carregar baseline do valor empresarial
  async loadBusinessValueBaseline(): Promise<number | null> {
    try {
      console.log('üìä [DataManager] Carregando baseline do valor empresarial...');
      
      const { data, error } = await this.supabase
        .from('system_settings')
        .select('value')
        .eq('key', 'business_value_baseline')
        .maybeSingle();

      if (error) {
        console.error('‚ùå [DataManager] Erro ao carregar baseline:', error);
        return null;
      }

      if (!data || !data.value || data.value.trim() === '') {
        console.log('üìä [DataManager] Baseline n√£o encontrado ou desativado');
        return null;
      }

      const baseline = parseFloat(data.value) || 0;
      console.log('‚úÖ [DataManager] Baseline do valor empresarial carregado:', baseline);
      return baseline;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro cr√≠tico ao carregar baseline do valor empresarial:', error);
      return null;
    }
  }

  // Fun√ß√£o para calcular lucro empresarial baseado na diferen√ßa do baseline
  async calculateBusinessProfit(): Promise<number> {
    try {
      console.log('üßÆ [DataManager] Calculando lucro empresarial baseado no baseline...');
      
      const currentValue = await this.loadBusinessValue();
      const baseline = await this.loadBusinessValueBaseline();
      
      if (baseline === null) {
        console.log('üìä [DataManager] Sem baseline definido, lucro empresarial = 0');
        return 0;
      }
      
      const profit = currentValue - baseline;
      console.log(`üí∞ [DataManager] Lucro calculado: R$ ${currentValue.toFixed(2)} - R$ ${baseline.toFixed(2)} = R$ ${profit.toFixed(2)}`);
      
      // Salvar o lucro calculado
      await this.saveBusinessProfit(profit);
      
      return profit;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao calcular lucro empresarial:', error);
      return 0;
    }
  }

  // Fun√ß√£o para confirmar balan√ßo empresarial (criar baseline)
  async confirmBusinessBalance(): Promise<boolean> {
    try {
      console.log('‚úÖ [DataManager] Confirmando balan√ßo empresarial...');
      
      const currentValue = await this.loadBusinessValue();
      const success = await this.saveBusinessValueBaseline(currentValue);
      
      if (success) {
        console.log(`üéØ [DataManager] Balan√ßo confirmado! Baseline definido como: R$ ${currentValue.toFixed(2)}`);
        
        // Salvar no hist√≥rico ap√≥s confirmar
        await this.saveBaselineHistory('confirm');
        
        // Recalcular o lucro (que ser√° 0 ap√≥s definir o baseline)
        await this.calculateBusinessProfit();
      }
      
      return success;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao confirmar balan√ßo empresarial:', error);
      return false;
    }
  }

  // Fun√ß√£o para zerar lucro empresarial (remover baseline)
  async resetBusinessProfit(): Promise<boolean> {
    try {
      console.log('üîÑ [DataManager] Zerando lucro empresarial (removendo baseline)...');
      
      // Primeiro, verificar se o baseline existe
      const { data: existingData, error: checkError } = await this.supabase
        .from('system_settings')
        .select('*')
        .eq('key', 'business_value_baseline')
        .maybeSingle();

      if (checkError) {
        console.error('‚ùå [DataManager] Erro ao verificar baseline existente:', checkError);
        return false;
      }

      if (!existingData) {
        console.log('‚ö†Ô∏è [DataManager] Baseline j√° n√£o existe no banco de dados');
        return true;
      }

      console.log('üîç [DataManager] Baseline encontrado, desativando via soft delete...');

      // Usar soft delete como m√©todo principal (mais confi√°vel)
      const { data: updateData, error: updateError } = await this.supabase
        .from('system_settings')
        .update({ 
          value: '',
          updated_at: new Date().toISOString()
        })
        .eq('id', existingData.id)
        .select();

      if (updateError) {
        console.error('‚ùå [DataManager] Erro ao desativar baseline:', updateError);
        return false;
      }

      console.log('‚úÖ [DataManager] Baseline desativado com sucesso (soft delete):', updateData);
      
      // Verificar se foi realmente desativado
      const { data: verifyData, error: verifyError } = await this.supabase
        .from('system_settings')
        .select('*')
        .eq('key', 'business_value_baseline')
        .maybeSingle();

      if (verifyError) {
        console.error('‚ùå [DataManager] Erro ao verificar desativa√ß√£o:', verifyError);
      } else if (verifyData && verifyData.value && verifyData.value.trim() !== '') {
        console.error('‚ùå [DataManager] ERRO: Baseline ainda ativo ap√≥s desativa√ß√£o!', verifyData);
        return false;
      } else {
        console.log('‚úÖ [DataManager] Verifica√ß√£o confirmada: Baseline foi desativado com sucesso!');
      }

      console.log('‚úÖ [DataManager] Sistema de lucro empresarial desativado.');
      
      // Recalcular o lucro (que ser√° 0 sem baseline)
      await this.calculateBusinessProfit();
      
      return true;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro ao desativar baseline:', error);
      return false;
    }
  }

  // Alias para melhor nomenclatura
  async deactivateBaseline(): Promise<boolean> {
    console.log('üîÑ [DataManager] Desativando baseline do sistema de lucro empresarial...');
    
    // Salvar no hist√≥rico antes de desativar
    await this.saveBaselineHistory('deactivate');
    
    return this.resetBusinessProfit();
  }

  // Salvar hist√≥rico de baseline
  async saveBaselineHistory(action: 'confirm' | 'deactivate' | 'redefine'): Promise<void> {
    try {
      const currentBaseline = await this.loadBusinessValueBaseline();
      const currentBusinessValue = await this.loadBusinessValue();
      const currentProfit = await this.loadBusinessProfit();

      if (currentBaseline !== null) {
        const historyData = {
          baseline_value: currentBaseline,
          business_value: currentBusinessValue,
          profit_value: currentProfit,
          action: action,
          timestamp: new Date().toISOString(),
          description: this.getActionDescription(action, currentBaseline, currentBusinessValue, currentProfit)
        };

        // Usar system_settings para armazenar hist√≥rico
        const historyKey = `baseline_history_${Date.now()}`;
        const { error } = await this.supabase
          .from('system_settings')
          .upsert({
            key: historyKey,
            value: JSON.stringify(historyData),
            description: `Hist√≥rico: ${action}`,
            created_at: new Date().toISOString()
          }, {
            onConflict: 'key'
          });

        if (error) {
          console.error('‚ùå [DataManager] Erro ao salvar hist√≥rico:', error);
        } else {
          console.log('‚úÖ [DataManager] Hist√≥rico salvo:', historyData);
        }
      }
    } catch (error) {
      console.error('‚ùå [DataManager] Erro cr√≠tico ao salvar hist√≥rico:', error);
    }
  }

  // Obter descri√ß√£o da a√ß√£o para o hist√≥rico
  private getActionDescription(action: string, baseline: number, businessValue: number, profit: number): string {
    const formatCurrency = (value: number) => new Intl.NumberFormat('pt-BR', {
      style: 'currency',
      currency: 'BRL'
    }).format(value);

    switch (action) {
      case 'confirm':
        return `Baseline confirmado em ${formatCurrency(baseline)} | Valor: ${formatCurrency(businessValue)} | Lucro: ${formatCurrency(profit)}`;
      case 'deactivate':
        return `Baseline desativado | Valor anterior: ${formatCurrency(baseline)} | Lucro anterior: ${formatCurrency(profit)}`;
      case 'redefine':
        return `Baseline redefinido para ${formatCurrency(baseline)} | Valor: ${formatCurrency(businessValue)} | Novo lucro: ${formatCurrency(profit)}`;
      default:
        return `A√ß√£o: ${action} | Baseline: ${formatCurrency(baseline)} | Valor: ${formatCurrency(businessValue)} | Lucro: ${formatCurrency(profit)}`;
    }
  }

  // Carregar hist√≥rico de baselines
  async loadBaselineHistory(): Promise<any[]> {
    try {
      const { data, error } = await this.supabase
        .from('system_settings')
        .select('*')
        .like('key', 'baseline_history_%')
        .order('created_at', { ascending: false })
        .limit(50);

      if (error) {
        console.error('‚ùå [DataManager] Erro ao carregar hist√≥rico:', error);
        return [];
      }

      // Parsear dados JSON do hist√≥rico
      const historyEntries = (data || []).map(entry => {
        try {
          const parsedValue = JSON.parse(entry.value);
          return {
            id: entry.id,
            key: entry.key,
            ...parsedValue,
            created_at: entry.created_at
          };
        } catch (parseError) {
          console.error('‚ùå [DataManager] Erro ao parsear entrada do hist√≥rico:', parseError);
          return null;
        }
      }).filter(entry => entry !== null);

      return historyEntries;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro cr√≠tico ao carregar hist√≥rico:', error);
      return [];
    }
  }

  // Restaurar baseline do hist√≥rico
  async restoreBaseline(historyKey: string): Promise<boolean> {
    try {
      // Buscar entrada do hist√≥rico
      const { data: historyData, error: historyError } = await this.supabase
        .from('system_settings')
        .select('*')
        .eq('key', historyKey)
        .single();

      if (historyError || !historyData) {
        console.error('‚ùå [DataManager] Erro ao buscar hist√≥rico:', historyError);
        return false;
      }

      // Parsear dados do hist√≥rico
      const parsedHistory = JSON.parse(historyData.value);

      // Salvar estado atual no hist√≥rico antes de restaurar
      await this.saveBaselineHistory('redefine');

      // Restaurar baseline
      const success = await this.saveBusinessValueBaseline(parsedHistory.baseline_value);
      
      if (success) {
        console.log('‚úÖ [DataManager] Baseline restaurado do hist√≥rico:', parsedHistory);
        
        // Recalcular lucro
        await this.calculateBusinessProfit();
        
        return true;
      }

      return false;
    } catch (error) {
      console.error('‚ùå [DataManager] Erro cr√≠tico ao restaurar baseline:', error);
      return false;
    }
  }

  // ==========================================
  // FUNCIONALIDADES DE BACKUP E RESTAURA√á√ÉO
  // ==========================================

  /**
   * Exporta toda a base de dados do sistema para backup
   */
  async exportDatabase(): Promise<string> {
    try {
      console.log('üîÑ [DataManager] Iniciando exporta√ß√£o da base de dados...');
      
      const exportData: any = {
        metadata: {
          exportDate: new Date().toISOString(),
          version: '1.0',
          system: 'SistemaRec'
        },
        data: {}
      };

      // Mapeamento das tabelas do sistema (backup_name -> actual_table)
      const tableMapping: { [key: string]: string } = {
        'clients': 'customers',
        'products': 'raw_materials', 
        'services': 'services',
        'transactions': 'cash_flow_entries',
        'tire_inventory': 'stock_items',
        'service_items': 'service_items',
        'system_settings': 'system_settings',
        'cash_flow': 'cash_flow_entries',
        'expenses': 'expenses'
      };

      // Exporta dados de cada tabela
      for (const [backupName, actualTable] of Object.entries(tableMapping)) {
        try {
          console.log(`üì• Exportando ${actualTable} -> ${backupName}`);
          
          const { data, error } = await this.supabase
            .from(actualTable as any)
            .select('*');

          if (error) {
            console.error(`‚ùå Erro ao exportar tabela ${actualTable}:`, error);
            exportData.data[backupName] = [];
          } else {
            exportData.data[backupName] = data || [];
            console.log(`‚úÖ Tabela ${actualTable} exportada: ${data?.length || 0} registros`);
          }
        } catch (tableError) {
          console.error(`‚ùå Erro cr√≠tico na exporta√ß√£o da tabela ${actualTable}:`, tableError);
          exportData.data[backupName] = [];
        }
      }

      console.log('‚úÖ [DataManager] Exporta√ß√£o conclu√≠da com sucesso');
      return JSON.stringify(exportData, null, 2);

    } catch (error) {
      console.error('‚ùå [DataManager] Erro cr√≠tico na exporta√ß√£o:', error);
      throw error;
    }
  }

  /**
   * Importa e restaura toda a base de dados do sistema
   */
  async importDatabase(jsonData: string): Promise<boolean> {
    try {
      console.log('üîÑ [DataManager] Iniciando importa√ß√£o da base de dados...');
      
      const importData = JSON.parse(jsonData);
      
      // Valida√ß√£o b√°sica da estrutura
      if (!importData.data || !importData.metadata) {
        console.error('‚ùå Estrutura de backup inv√°lida');
        return false;
      }

      console.log('üìä Backup v√°lido encontrado:', importData.metadata);

      // Mapeamento correto das tabelas do sistema
      const tableMapping: { [key: string]: string } = {
        'clients': 'customers',
        'products': 'raw_materials', 
        'services': 'services',
        'transactions': 'cash_flow_entries',
        'tire_inventory': 'stock_items',
        'service_items': 'service_items',
        'system_settings': 'system_settings',
        'cash_flow': 'cash_flow_entries',
        'expenses': 'expenses'
      };

      let successCount = 0;
      let errorCount = 0;

      // Processa cada tabela do backup
      for (const [backupTable, actualTable] of Object.entries(tableMapping)) {
        try {
          const tableData = importData.data[backupTable];
          
          if (!tableData || !Array.isArray(tableData)) {
            console.log(`‚ö†Ô∏è Tabela ${backupTable} n√£o encontrada no backup ou vazia`);
            continue;
          }

          console.log(`üì• Importando ${backupTable} -> ${actualTable} (${tableData.length} registros)`);

          // Para system_settings, usa upsert para n√£o duplicar
          if (actualTable === 'system_settings') {
            const { error: upsertError } = await this.supabase
              .from(actualTable as any)
              .upsert(tableData, { onConflict: 'key' });

            if (upsertError) {
              console.error(`‚ùå Erro ao fazer upsert na tabela ${actualTable}:`, upsertError);
              errorCount++;
            } else {
              console.log(`‚úÖ Tabela ${actualTable} importada com sucesso`);
              successCount++;
            }
          } else {
            // Para outras tabelas, usa estrat√©gia de upsert com IDs preservados
            console.log(`üîÑ Fazendo upsert de ${tableData.length} registros na tabela ${actualTable}`);
            
            // Processa em lotes menores
            const batchSize = 20;
            let batchSuccessCount = 0;
            
            for (let i = 0; i < tableData.length; i += batchSize) {
              const batch = tableData.slice(i, i + batchSize);
              console.log(`üì¶ Processando lote ${Math.floor(i/batchSize) + 1} (${batch.length} registros)`);

              try {
                const { error: upsertError } = await this.supabase
                  .from(actualTable as any)
                  .upsert(batch, { 
                    onConflict: 'id',
                    ignoreDuplicates: false 
                  });

                if (upsertError) {
                  console.error(`‚ùå Erro no lote ${Math.floor(i/batchSize) + 1} da tabela ${actualTable}:`, upsertError);
                  
                  // Tenta inserir registros individualmente se o lote falhar
                  for (const record of batch) {
                    try {
                      const { error: singleError } = await this.supabase
                        .from(actualTable as any)
                        .upsert(record, { onConflict: 'id' });
                      
                      if (!singleError) {
                        batchSuccessCount++;
                      }
                    } catch (singleRecordError) {
                      console.error(`‚ùå Erro no registro individual:`, singleRecordError);
                    }
                  }
                } else {
                  batchSuccessCount += batch.length;
                  console.log(`‚úÖ Lote ${Math.floor(i/batchSize) + 1} inserido com sucesso`);
                }
              } catch (batchError) {
                console.error(`‚ùå Erro cr√≠tico no lote ${Math.floor(i/batchSize) + 1}:`, batchError);
              }
            }
            
            if (batchSuccessCount > 0) {
              console.log(`‚úÖ Tabela ${actualTable}: ${batchSuccessCount}/${tableData.length} registros importados`);
              successCount++;
            } else {
              console.error(`‚ùå Falha completa na importa√ß√£o da tabela ${actualTable}`);
              errorCount++;
            }
          }

        } catch (tableError) {
          console.error(`‚ùå Erro cr√≠tico na importa√ß√£o da tabela ${backupTable}:`, tableError);
          errorCount++;
        }
      }

      console.log(`üìä Importa√ß√£o finalizada: ${successCount} sucessos, ${errorCount} erros`);
      
      if (successCount > 0) {
        console.log('‚úÖ [DataManager] Importa√ß√£o conclu√≠da com sucesso');
        return true;
      } else {
        console.log('‚ùå [DataManager] Falha na importa√ß√£o');
        return false;
      }

    } catch (error) {
      console.error('‚ùå [DataManager] Erro cr√≠tico na importa√ß√£o:', error);
      return false;
    }
  }

  // Debt methods
  async saveDebt(
    debt: Omit<Debt, "id" | "created_at" | "updated_at">
  ): Promise<Debt | null> {
    console.log("üöÄ [DataManager] Iniciando saveDebt...");
    console.log("üìù [DataManager] Dados da d√≠vida:", debt);
    console.log("üóÑÔ∏è [DataManager] Salvando na tabela: debts");
    
    try {
      const result = await this.saveToDatabase<Debt>("debts", debt as any);
      console.log("üì• [DataManager] Resultado do saveToDatabase:", result);
      return result;
    } catch (error) {
      console.error("‚ùå [DataManager] Erro em saveDebt:", error);
      throw error;
    }
  }

  async loadDebts(): Promise<Debt[]> {
    try {
      const rawData = await this.loadFromDatabase<any>("debts");
      console.log("üîç [DataManager] Raw debts data from database:", rawData);
      
      // Convert string values to numbers to ensure proper formatting
      const processedData = rawData.map((debt: any) => {
        const processed = {
          ...debt,
          total_amount: typeof debt.total_amount === 'string' ? parseFloat(debt.total_amount) : debt.total_amount,
          paid_amount: typeof debt.paid_amount === 'string' ? parseFloat(debt.paid_amount) : debt.paid_amount,
          remaining_amount: typeof debt.remaining_amount === 'string' ? parseFloat(debt.remaining_amount) : debt.remaining_amount,
        };
        
        console.log("üîç [DataManager] Processed debt:", {
          id: processed.id,
          description: processed.description,
          total_amount: processed.total_amount,
          paid_amount: processed.paid_amount,
          remaining_amount: processed.remaining_amount,
          types: {
            total_amount: typeof processed.total_amount,
            paid_amount: typeof processed.paid_amount,
            remaining_amount: typeof processed.remaining_amount,
          }
        });
        
        return processed;
      });
      
      console.log("‚úÖ [DataManager] Processed debts data:", processedData.length);
      return processedData as Debt[];
    } catch (error) {
      console.error("‚ùå [DataManager] Error loading debts:", error);
      return [];
    }
  }

  async updateDebt(
    id: string,
    updates: Partial<Debt>
  ): Promise<boolean> {
    console.log("üîÑ [DataManager] updateDebt iniciado:", {
      id,
      updates,
      updateTypes: Object.keys(updates).reduce((acc, key) => {
        acc[key] = typeof updates[key as keyof Debt];
        return acc;
      }, {} as Record<string, string>)
    });
    
    // Ensure numeric values are properly formatted
    const sanitizedUpdates = { ...updates };
    if (sanitizedUpdates.paid_amount !== undefined) {
      sanitizedUpdates.paid_amount = Number(sanitizedUpdates.paid_amount) || 0;
    }
    if (sanitizedUpdates.remaining_amount !== undefined) {
      sanitizedUpdates.remaining_amount = Number(sanitizedUpdates.remaining_amount) || 0;
    }
    if (sanitizedUpdates.total_amount !== undefined) {
      sanitizedUpdates.total_amount = Number(sanitizedUpdates.total_amount) || 0;
    }
    
    console.log("üîÑ [DataManager] updateDebt valores sanitizados:", {
      id,
      sanitizedUpdates,
      sanitizedTypes: Object.keys(sanitizedUpdates).reduce((acc, key) => {
        acc[key] = typeof sanitizedUpdates[key as keyof Debt];
        return acc;
      }, {} as Record<string, string>)
    });
    
    const result = await this.updateInDatabase("debts", id, sanitizedUpdates);
    
    console.log("üîÑ [DataManager] updateDebt resultado:", {
      id,
      result,
      originalUpdates: updates,
      sanitizedUpdates
    });
    
    return result;
  }

  async deleteDebt(id: string): Promise<boolean> {
    return this.deleteFromDatabase("debts", id);
  }

  /**
   * Gera nome do arquivo de backup
   */
  generateBackupFileName(): string {
    const now = new Date();
    const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
    const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
    return `sistemarec_backup_${dateStr}_${timeStr}.json`;
  }

  // Tire Cost History methods
  async saveTireCostHistory(
    date: string,
    averageCostPerTire: number
  ): Promise<boolean> {
    try {
      console.log("üíæ [DataManager] Salvando hist√≥rico de custo por pneu:", {
        date,
        averageCostPerTire
      });

      // Check if record for this date already exists
      const { data: existingRecord, error: checkError } = await (this.supabase as any)
        .from("tire_cost_history")
        .select("*")
        .eq("date", date)
        .single();

      if (checkError && checkError.code !== 'PGRST116') {
        console.error("‚ùå [DataManager] Erro ao verificar hist√≥rico existente:", checkError);
        throw checkError;
      }

      if (existingRecord) {
        // Update existing record
        const { error: updateError } = await (this.supabase as any)
          .from("tire_cost_history")
          .update({
            average_cost_per_tire: averageCostPerTire,
            updated_at: new Date().toISOString()
          })
          .eq("date", date);

        if (updateError) {
          console.error("‚ùå [DataManager] Erro ao atualizar hist√≥rico:", updateError);
          throw updateError;
        }

        console.log("‚úÖ [DataManager] Hist√≥rico de custo atualizado para:", date);
      } else {
        // Insert new record
        const { error: insertError } = await (this.supabase as any)
          .from("tire_cost_history")
          .insert([{
            date,
            average_cost_per_tire: averageCostPerTire
          }]);

        if (insertError) {
          console.error("‚ùå [DataManager] Erro ao inserir hist√≥rico:", insertError);
          throw insertError;
        }

        console.log("‚úÖ [DataManager] Novo hist√≥rico de custo salvo para:", date);
      }

      return true;
    } catch (error) {
      console.error("‚ùå [DataManager] Erro em saveTireCostHistory:", error);
      return false;
    }
  }

  async loadTireCostHistory(days: number = 30): Promise<Array<{date: string, cost: number}>> {
    try {
      console.log(`üìä [DataManager] Carregando hist√≥rico de custos dos √∫ltimos ${days} dias`);

      // Calculate date range with WORKAROUND +1 for end date to include today's record
      const endDate = new Date();
      const endDateWithWorkaround = new Date(endDate);
      endDateWithWorkaround.setDate(endDate.getDate() + 1); // +1 day workaround
      
      const startDate = new Date();
      startDate.setDate(endDate.getDate() - days);

      const startDateStr = startDate.toISOString().split('T')[0];
      const endDateStr = endDateWithWorkaround.toISOString().split('T')[0];
      
      console.log("üìÖ [DataManager] WORKAROUND +1: Range de datas para busca:", {
        startDate: startDateStr,
        endDate: endDateStr,
        endDateOriginal: endDate.toISOString().split('T')[0]
      });

      const { data, error } = await (this.supabase as any)
        .from("tire_cost_history")
        .select("date, average_cost_per_tire")
        .gte("date", startDateStr)
        .lte("date", endDateStr)
        .order("date", { ascending: true });

      if (error) {
        console.error("‚ùå [DataManager] Erro ao carregar hist√≥rico:", error);
        throw error;
      }

      const chartData = (data || []).map((record: any) => ({
        date: new Date(record.date).toLocaleDateString('pt-BR', {
          day: '2-digit',
          month: '2-digit'
        }),
        cost: parseFloat(record.average_cost_per_tire.toString())
      }));

      console.log("‚úÖ [DataManager] Hist√≥rico carregado:", chartData.length, "registros");
      return chartData;
    } catch (error) {
      console.error("‚ùå [DataManager] Erro em loadTireCostHistory:", error);
      return [];
    }
  }

  async getTodayTireCostRecord(): Promise<{date: string, cost: number} | null> {
    try {
      // WORKAROUND: Add +1 day to compensate Supabase UTC conversion
      const today = new Date();
      const tomorrow = new Date(today);
      tomorrow.setDate(today.getDate() + 1);
      const todayLocal = `${tomorrow.getFullYear()}-${String(tomorrow.getMonth() + 1).padStart(2, "0")}-${String(tomorrow.getDate()).padStart(2, "0")}`;
      
      console.log("üìÖ [DataManager] WORKAROUND +1: Buscando registro para data:", todayLocal);
      
      const { data, error } = await (this.supabase as any)
        .from("tire_cost_history")
        .select("date, average_cost_per_tire")
        .eq("date", todayLocal)
        .single();

      if (error && error.code !== 'PGRST116') {
        console.error("‚ùå [DataManager] Erro ao buscar registro de hoje:", error);
        throw error;
      }

      if (data) {
        return {
          date: data.date,
          cost: parseFloat(data.average_cost_per_tire.toString())
        };
      }

      return null;
    } catch (error) {
      console.error("‚ùå [DataManager] Erro em getTodayTireCostRecord:", error);
      return null;
    }
  }
}

// Export singleton instance
export const dataManager = DataManager.getInstance();

// Storage keys constants
export const STORAGE_KEYS = {
  MATERIALS: "tire-factory-materials",
  EMPLOYEES: "tire-factory-employees",
  CUSTOMERS: "tire-factory-customers",
  PRODUCTS: "tire-factory-products",
  SUPPLIERS: "tire-factory-suppliers",
  CUSTOM_UNITS: "tire-factory-custom-units",
  STOCK_ITEMS: "tire-factory-stock-items",
  RECIPES: "tire-factory-recipes",
  PRODUCTION_ENTRIES: "tire-factory-production-entries"

} as const;